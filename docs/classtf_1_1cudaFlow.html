<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Taskflow Handbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/x-icon" href="favicon.ico" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="taskflow_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://taskflow.github.io/">Taskflow</a>
   &#160;<span id="projectnumber">3.2.0-Master-Branch</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtf_1_1cudaFlow.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtf_1_1cudaFlow-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tf::cudaFlow Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>class to create a cudaFlow task dependency graph  
 <a href="classtf_1_1cudaFlow.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cudaflow_8hpp_source.html">cudaflow.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4c3e001db151486c8479151a2108d37" id="r_ad4c3e001db151486c8479151a2108d37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#ad4c3e001db151486c8479151a2108d37">cudaFlow</a> ()</td></tr>
<tr class="memdesc:ad4c3e001db151486c8479151a2108d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a standalone cudaFlow  <br /></td></tr>
<tr class="separator:ad4c3e001db151486c8479151a2108d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19eda378f8c0ef4495e08996f63f5144" id="r_a19eda378f8c0ef4495e08996f63f5144"><td class="memItemLeft" align="right" valign="top"><a id="a19eda378f8c0ef4495e08996f63f5144" name="a19eda378f8c0ef4495e08996f63f5144"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~cudaFlow</b> ()</td></tr>
<tr class="memdesc:a19eda378f8c0ef4495e08996f63f5144"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroys the cudaFlow and its associated native CUDA graph and executable graph <br /></td></tr>
<tr class="separator:a19eda378f8c0ef4495e08996f63f5144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1926f45a038d8faa9c1b1ee43fd29a93" id="r_a1926f45a038d8faa9c1b1ee43fd29a93"><td class="memItemLeft" align="right" valign="top"><a id="a1926f45a038d8faa9c1b1ee43fd29a93" name="a1926f45a038d8faa9c1b1ee43fd29a93"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a1926f45a038d8faa9c1b1ee43fd29a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the emptiness of the graph <br /></td></tr>
<tr class="separator:a1926f45a038d8faa9c1b1ee43fd29a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6560c27d249af7e4b8b921388f5e1e2" id="r_ae6560c27d249af7e4b8b921388f5e1e2"><td class="memItemLeft" align="right" valign="top"><a id="ae6560c27d249af7e4b8b921388f5e1e2" name="ae6560c27d249af7e4b8b921388f5e1e2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_tasks</b> () const</td></tr>
<tr class="memdesc:ae6560c27d249af7e4b8b921388f5e1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the number of tasks <br /></td></tr>
<tr class="separator:ae6560c27d249af7e4b8b921388f5e1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad726dfe21e9719d96c65530a56d9951" id="r_aad726dfe21e9719d96c65530a56d9951"><td class="memItemLeft" align="right" valign="top"><a id="aad726dfe21e9719d96c65530a56d9951" name="aad726dfe21e9719d96c65530a56d9951"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:aad726dfe21e9719d96c65530a56d9951"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the cudaFlow object <br /></td></tr>
<tr class="separator:aad726dfe21e9719d96c65530a56d9951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f97b68fa7c889db49b26aa71a46a7cf" id="r_a7f97b68fa7c889db49b26aa71a46a7cf"><td class="memItemLeft" align="right" valign="top"><a id="a7f97b68fa7c889db49b26aa71a46a7cf" name="a7f97b68fa7c889db49b26aa71a46a7cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os) const</td></tr>
<tr class="memdesc:a7f97b68fa7c889db49b26aa71a46a7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumps the cudaFlow graph into a DOT format through an output stream <br /></td></tr>
<tr class="separator:a7f97b68fa7c889db49b26aa71a46a7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43507f21eb9cb77667ffe0ac7e6ae635" id="r_a43507f21eb9cb77667ffe0ac7e6ae635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a43507f21eb9cb77667ffe0ac7e6ae635">dump_native_graph</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os) const</td></tr>
<tr class="memdesc:a43507f21eb9cb77667ffe0ac7e6ae635"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumps the native CUDA graph into a DOT format through an output stream  <br /></td></tr>
<tr class="separator:a43507f21eb9cb77667ffe0ac7e6ae635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b2e107cb2c90a37f467b28d1b42a74" id="r_a30b2e107cb2c90a37f467b28d1b42a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a30b2e107cb2c90a37f467b28d1b42a74">noop</a> ()</td></tr>
<tr class="memdesc:a30b2e107cb2c90a37f467b28d1b42a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a no-operation task  <br /></td></tr>
<tr class="separator:a30b2e107cb2c90a37f467b28d1b42a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060e1c96111c2134ce0f896420a42cd0" id="r_a060e1c96111c2134ce0f896420a42cd0"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a060e1c96111c2134ce0f896420a42cd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a060e1c96111c2134ce0f896420a42cd0">host</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a060e1c96111c2134ce0f896420a42cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a host task that runs a callable on the host  <br /></td></tr>
<tr class="separator:a060e1c96111c2134ce0f896420a42cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e4e5cf7d03b9d087d6fbf54eb86bbf" id="r_a02e4e5cf7d03b9d087d6fbf54eb86bbf"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a02e4e5cf7d03b9d087d6fbf54eb86bbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a02e4e5cf7d03b9d087d6fbf54eb86bbf">host</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a02e4e5cf7d03b9d087d6fbf54eb86bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a host task  <br /></td></tr>
<tr class="separator:a02e4e5cf7d03b9d087d6fbf54eb86bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e734462c8b8d922f44e621f94b104c" id="r_aa6e734462c8b8d922f44e621f94b104c"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:aa6e734462c8b8d922f44e621f94b104c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a> (dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa6e734462c8b8d922f44e621f94b104c"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a kernel task  <br /></td></tr>
<tr class="separator:aa6e734462c8b8d922f44e621f94b104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee746bd98fbb04326d1e76dab9b955c" id="r_a6ee746bd98fbb04326d1e76dab9b955c"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:a6ee746bd98fbb04326d1e76dab9b955c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a6ee746bd98fbb04326d1e76dab9b955c">kernel</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, dim3 g, dim3 b, size_t shm, F f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6ee746bd98fbb04326d1e76dab9b955c"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task  <br /></td></tr>
<tr class="separator:a6ee746bd98fbb04326d1e76dab9b955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ca65da35301e5aafd45878a19e9d2" id="r_a079ca65da35301e5aafd45878a19e9d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a079ca65da35301e5aafd45878a19e9d2">memset</a> (void *dst, int v, size_t count)</td></tr>
<tr class="memdesc:a079ca65da35301e5aafd45878a19e9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a memset task that fills untyped data with a byte value  <br /></td></tr>
<tr class="separator:a079ca65da35301e5aafd45878a19e9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082505f0fec89f65808421cdc737fb17" id="r_a082505f0fec89f65808421cdc737fb17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a082505f0fec89f65808421cdc737fb17">memset</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, void *dst, int ch, size_t count)</td></tr>
<tr class="memdesc:a082505f0fec89f65808421cdc737fb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a memset task  <br /></td></tr>
<tr class="separator:a082505f0fec89f65808421cdc737fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37637606f0643f360e9eda1f9a6e559" id="r_ad37637606f0643f360e9eda1f9a6e559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#ad37637606f0643f360e9eda1f9a6e559">memcpy</a> (void *tgt, const void *src, size_t bytes)</td></tr>
<tr class="memdesc:ad37637606f0643f360e9eda1f9a6e559"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a memcpy task that copies untyped data in bytes  <br /></td></tr>
<tr class="separator:ad37637606f0643f360e9eda1f9a6e559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9e6cfa65cbfcd1d33c88e64b487ce6" id="r_acf9e6cfa65cbfcd1d33c88e64b487ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#acf9e6cfa65cbfcd1d33c88e64b487ce6">memcpy</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, void *tgt, const void *src, size_t bytes)</td></tr>
<tr class="memdesc:acf9e6cfa65cbfcd1d33c88e64b487ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a memcpy task  <br /></td></tr>
<tr class="separator:acf9e6cfa65cbfcd1d33c88e64b487ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40172fac4464f6d805f75921ea3c2a3b" id="r_a40172fac4464f6d805f75921ea3c2a3b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a40172fac4464f6d805f75921ea3c2a3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">zero</a> (T *dst, size_t count)</td></tr>
<tr class="memdesc:a40172fac4464f6d805f75921ea3c2a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a memset task that sets a typed memory block to zero  <br /></td></tr>
<tr class="separator:a40172fac4464f6d805f75921ea3c2a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c2a73243809e3cbd1955cc1ffe6477" id="r_a78c2a73243809e3cbd1955cc1ffe6477"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a78c2a73243809e3cbd1955cc1ffe6477"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a78c2a73243809e3cbd1955cc1ffe6477">zero</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, T *dst, size_t count)</td></tr>
<tr class="memdesc:a78c2a73243809e3cbd1955cc1ffe6477"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a memset task to a zero task  <br /></td></tr>
<tr class="separator:a78c2a73243809e3cbd1955cc1ffe6477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d4447bc834f4d3e1bb4772c850d090" id="r_a21d4447bc834f4d3e1bb4772c850d090"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a21d4447bc834f4d3e1bb4772c850d090"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a21d4447bc834f4d3e1bb4772c850d090">fill</a> (T *dst, T value, size_t count)</td></tr>
<tr class="memdesc:a21d4447bc834f4d3e1bb4772c850d090"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a memset task that fills a typed memory block with a value  <br /></td></tr>
<tr class="separator:a21d4447bc834f4d3e1bb4772c850d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ed97c9142959c73d4c25c34d71bd5e" id="r_a39ed97c9142959c73d4c25c34d71bd5e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a39ed97c9142959c73d4c25c34d71bd5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a39ed97c9142959c73d4c25c34d71bd5e">fill</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, T *dst, T value, size_t count)</td></tr>
<tr class="memdesc:a39ed97c9142959c73d4c25c34d71bd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a memset task to a fill task  <br /></td></tr>
<tr class="separator:a39ed97c9142959c73d4c25c34d71bd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03e04771b655f9e629eb4c22e19b19f" id="r_af03e04771b655f9e629eb4c22e19b19f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af03e04771b655f9e629eb4c22e19b19f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">copy</a> (T *tgt, const T *src, size_t num)</td></tr>
<tr class="memdesc:af03e04771b655f9e629eb4c22e19b19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a memcopy task that copies typed data  <br /></td></tr>
<tr class="separator:af03e04771b655f9e629eb4c22e19b19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf6ec1e85172fa99c16bf0beffc0562" id="r_a6cf6ec1e85172fa99c16bf0beffc0562"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6cf6ec1e85172fa99c16bf0beffc0562"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a6cf6ec1e85172fa99c16bf0beffc0562">copy</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, T *tgt, const T *src, size_t num)</td></tr>
<tr class="memdesc:a6cf6ec1e85172fa99c16bf0beffc0562"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a memcpy task to a copy task  <br /></td></tr>
<tr class="separator:a6cf6ec1e85172fa99c16bf0beffc0562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99358da15e3bdfa1faabb3e326130e1f" id="r_a99358da15e3bdfa1faabb3e326130e1f"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a99358da15e3bdfa1faabb3e326130e1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a99358da15e3bdfa1faabb3e326130e1f">offload_until</a> (P &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a99358da15e3bdfa1faabb3e326130e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">offloads the cudaFlow onto a GPU and repeatedly runs it until the predicate becomes true  <br /></td></tr>
<tr class="separator:a99358da15e3bdfa1faabb3e326130e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2269fd7dc8ca04a294a718204703dad" id="r_ac2269fd7dc8ca04a294a718204703dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#ac2269fd7dc8ca04a294a718204703dad">offload_n</a> (size_t N)</td></tr>
<tr class="memdesc:ac2269fd7dc8ca04a294a718204703dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">offloads the cudaFlow and executes it by the given times  <br /></td></tr>
<tr class="separator:ac2269fd7dc8ca04a294a718204703dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85789ed8a1f47704cf1f1a2b98969444" id="r_a85789ed8a1f47704cf1f1a2b98969444"><td class="memItemLeft" align="right" valign="top"><a id="a85789ed8a1f47704cf1f1a2b98969444" name="a85789ed8a1f47704cf1f1a2b98969444"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>offload</b> ()</td></tr>
<tr class="memdesc:a85789ed8a1f47704cf1f1a2b98969444"><td class="mdescLeft">&#160;</td><td class="mdescRight">offloads the cudaFlow and executes it once <br /></td></tr>
<tr class="separator:a85789ed8a1f47704cf1f1a2b98969444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2906cb0002fc411a983d100a3d58d62" id="r_ac2906cb0002fc411a983d100a3d58d62"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ac2906cb0002fc411a983d100a3d58d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#ac2906cb0002fc411a983d100a3d58d62">single_task</a> (C c)</td></tr>
<tr class="memdesc:ac2906cb0002fc411a983d100a3d58d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a callable with only a single kernel thread  <br /></td></tr>
<tr class="separator:ac2906cb0002fc411a983d100a3d58d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2d364f38c72322d8e36bc0da0b98e4" id="r_add2d364f38c72322d8e36bc0da0b98e4"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:add2d364f38c72322d8e36bc0da0b98e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#add2d364f38c72322d8e36bc0da0b98e4">single_task</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, C c)</td></tr>
<tr class="memdesc:add2d364f38c72322d8e36bc0da0b98e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a single-threaded kernel task  <br /></td></tr>
<tr class="separator:add2d364f38c72322d8e36bc0da0b98e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a681f6223853b6445dcfdad07e4d0fd" id="r_a1a681f6223853b6445dcfdad07e4d0fd"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a1a681f6223853b6445dcfdad07e4d0fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a1a681f6223853b6445dcfdad07e4d0fd">for_each</a> (I first, I last, C callable)</td></tr>
<tr class="memdesc:a1a681f6223853b6445dcfdad07e4d0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a callable to each dereferenced element of the data array  <br /></td></tr>
<tr class="separator:a1a681f6223853b6445dcfdad07e4d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc7ee16602754929bb9118a9d7f0b2" id="r_af9cc7ee16602754929bb9118a9d7f0b2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:af9cc7ee16602754929bb9118a9d7f0b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#af9cc7ee16602754929bb9118a9d7f0b2">for_each</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, C callable)</td></tr>
<tr class="memdesc:af9cc7ee16602754929bb9118a9d7f0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a1a681f6223853b6445dcfdad07e4d0fd" title="applies a callable to each dereferenced element of the data array">tf::cudaFlow::for_each</a>  <br /></td></tr>
<tr class="separator:af9cc7ee16602754929bb9118a9d7f0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f1ea89e5651faa6e8af522a42556ac" id="r_a34f1ea89e5651faa6e8af522a42556ac"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a34f1ea89e5651faa6e8af522a42556ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a34f1ea89e5651faa6e8af522a42556ac">for_each_index</a> (I first, I last, I step, C callable)</td></tr>
<tr class="memdesc:a34f1ea89e5651faa6e8af522a42556ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a callable to each index in the range with the step size  <br /></td></tr>
<tr class="separator:a34f1ea89e5651faa6e8af522a42556ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa7f8e38b4da1fe0cbcfb265f9349a2" id="r_a3fa7f8e38b4da1fe0cbcfb265f9349a2"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a3fa7f8e38b4da1fe0cbcfb265f9349a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a3fa7f8e38b4da1fe0cbcfb265f9349a2">for_each_index</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, I step, C callable)</td></tr>
<tr class="memdesc:a3fa7f8e38b4da1fe0cbcfb265f9349a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a34f1ea89e5651faa6e8af522a42556ac" title="applies a callable to each index in the range with the step size">tf::cudaFlow::for_each_index</a>  <br /></td></tr>
<tr class="separator:a3fa7f8e38b4da1fe0cbcfb265f9349a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89a9bda182272462a0eda2581536cd8" id="r_af89a9bda182272462a0eda2581536cd8"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:af89a9bda182272462a0eda2581536cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#af89a9bda182272462a0eda2581536cd8">transform</a> (I first, I last, O output, C op)</td></tr>
<tr class="memdesc:af89a9bda182272462a0eda2581536cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a callable to a source range and stores the result in a target range  <br /></td></tr>
<tr class="separator:af89a9bda182272462a0eda2581536cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a211b1f8562e10f9aae8b44fd6acdec" id="r_a4a211b1f8562e10f9aae8b44fd6acdec"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a4a211b1f8562e10f9aae8b44fd6acdec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a4a211b1f8562e10f9aae8b44fd6acdec">transform</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, C c)</td></tr>
<tr class="memdesc:a4a211b1f8562e10f9aae8b44fd6acdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#af89a9bda182272462a0eda2581536cd8" title="applies a callable to a source range and stores the result in a target range">tf::cudaFlow::transform</a>  <br /></td></tr>
<tr class="separator:a4a211b1f8562e10f9aae8b44fd6acdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab2bfdfc86ef3a764ece4743fdede76" id="r_abab2bfdfc86ef3a764ece4743fdede76"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 , typename O , typename C &gt; </td></tr>
<tr class="memitem:abab2bfdfc86ef3a764ece4743fdede76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#abab2bfdfc86ef3a764ece4743fdede76">transform</a> (I1 first1, I1 last1, I2 first2, O output, C op)</td></tr>
<tr class="memdesc:abab2bfdfc86ef3a764ece4743fdede76"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to perform parallel transforms over two ranges of items  <br /></td></tr>
<tr class="separator:abab2bfdfc86ef3a764ece4743fdede76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6ca7be2b6908e8f71570c54303ba9e" id="r_a7c6ca7be2b6908e8f71570c54303ba9e"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 , typename O , typename C &gt; </td></tr>
<tr class="memitem:a7c6ca7be2b6908e8f71570c54303ba9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a7c6ca7be2b6908e8f71570c54303ba9e">transform</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I1 first1, I1 last1, I2 first2, O output, C c)</td></tr>
<tr class="memdesc:a7c6ca7be2b6908e8f71570c54303ba9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#af89a9bda182272462a0eda2581536cd8" title="applies a callable to a source range and stores the result in a target range">tf::cudaFlow::transform</a>  <br /></td></tr>
<tr class="separator:a7c6ca7be2b6908e8f71570c54303ba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931a0f99034bccf377aea35e221f50bc" id="r_a931a0f99034bccf377aea35e221f50bc"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename B &gt; </td></tr>
<tr class="memitem:a931a0f99034bccf377aea35e221f50bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a931a0f99034bccf377aea35e221f50bc">reduce</a> (I first, I last, T *result, B bop)</td></tr>
<tr class="memdesc:a931a0f99034bccf377aea35e221f50bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs parallel reduction over a range of items  <br /></td></tr>
<tr class="separator:a931a0f99034bccf377aea35e221f50bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b56bc5ec489f4ed0da2c2826f4e9345" id="r_a4b56bc5ec489f4ed0da2c2826f4e9345"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C &gt; </td></tr>
<tr class="memitem:a4b56bc5ec489f4ed0da2c2826f4e9345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a4b56bc5ec489f4ed0da2c2826f4e9345">reduce</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, T *result, C op)</td></tr>
<tr class="memdesc:a4b56bc5ec489f4ed0da2c2826f4e9345"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a931a0f99034bccf377aea35e221f50bc" title="performs parallel reduction over a range of items">tf::cudaFlow::reduce</a>  <br /></td></tr>
<tr class="separator:a4b56bc5ec489f4ed0da2c2826f4e9345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5189b9c9494d2a63a983c32cf234f6" id="r_a3a5189b9c9494d2a63a983c32cf234f6"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename B &gt; </td></tr>
<tr class="memitem:a3a5189b9c9494d2a63a983c32cf234f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a3a5189b9c9494d2a63a983c32cf234f6">uninitialized_reduce</a> (I first, I last, T *result, B bop)</td></tr>
<tr class="memdesc:a3a5189b9c9494d2a63a983c32cf234f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlow.html#a931a0f99034bccf377aea35e221f50bc" title="performs parallel reduction over a range of items">tf::cudaFlow::reduce</a> but does not assume any initial value to reduce  <br /></td></tr>
<tr class="separator:a3a5189b9c9494d2a63a983c32cf234f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096b655c4d8c9a4d5d250cdce6a49c59" id="r_a096b655c4d8c9a4d5d250cdce6a49c59"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C &gt; </td></tr>
<tr class="memitem:a096b655c4d8c9a4d5d250cdce6a49c59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a096b655c4d8c9a4d5d250cdce6a49c59">uninitialized_reduce</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, T *result, C op)</td></tr>
<tr class="memdesc:a096b655c4d8c9a4d5d250cdce6a49c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a3a5189b9c9494d2a63a983c32cf234f6" title="similar to tf::cudaFlow::reduce but does not assume any initial value to reduce">tf::cudaFlow::uninitialized_reduce</a>  <br /></td></tr>
<tr class="separator:a096b655c4d8c9a4d5d250cdce6a49c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af5d4e8a3820f9b9d8abbe4f4f6c4a4" id="r_a1af5d4e8a3820f9b9d8abbe4f4f6c4a4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename B , typename U &gt; </td></tr>
<tr class="memitem:a1af5d4e8a3820f9b9d8abbe4f4f6c4a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a1af5d4e8a3820f9b9d8abbe4f4f6c4a4">transform_reduce</a> (I first, I last, T *result, B bop, U uop)</td></tr>
<tr class="memdesc:a1af5d4e8a3820f9b9d8abbe4f4f6c4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs parallel reduction over a range of transformed items  <br /></td></tr>
<tr class="separator:a1af5d4e8a3820f9b9d8abbe4f4f6c4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac600a831b8bac389f2fbd1b384c6df5a" id="r_ac600a831b8bac389f2fbd1b384c6df5a"><td class="memTemplParams" colspan="2"><a id="ac600a831b8bac389f2fbd1b384c6df5a" name="ac600a831b8bac389f2fbd1b384c6df5a"></a>
template&lt;typename I , typename T , typename B , typename U &gt; </td></tr>
<tr class="memitem:ac600a831b8bac389f2fbd1b384c6df5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_reduce</b> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>, I first, I last, T *result, B bop, U uop)</td></tr>
<tr class="memdesc:ac600a831b8bac389f2fbd1b384c6df5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a1af5d4e8a3820f9b9d8abbe4f4f6c4a4" title="performs parallel reduction over a range of transformed items">tf::cudaFlow::transform_reduce</a> <br /></td></tr>
<tr class="separator:ac600a831b8bac389f2fbd1b384c6df5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9716ae4016ac058b32becef119faaddd" id="r_a9716ae4016ac058b32becef119faaddd"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename B , typename U &gt; </td></tr>
<tr class="memitem:a9716ae4016ac058b32becef119faaddd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a9716ae4016ac058b32becef119faaddd">transform_uninitialized_reduce</a> (I first, I last, T *result, B bop, U uop)</td></tr>
<tr class="memdesc:a9716ae4016ac058b32becef119faaddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlow.html#a1af5d4e8a3820f9b9d8abbe4f4f6c4a4" title="performs parallel reduction over a range of transformed items">tf::cudaFlow::transform_reduce</a> but does not assume any initial value to reduce  <br /></td></tr>
<tr class="separator:a9716ae4016ac058b32becef119faaddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1ffcdcb56cdf9f4cb896b52d07a6c4" id="r_a2d1ffcdcb56cdf9f4cb896b52d07a6c4"><td class="memTemplParams" colspan="2"><a id="a2d1ffcdcb56cdf9f4cb896b52d07a6c4" name="a2d1ffcdcb56cdf9f4cb896b52d07a6c4"></a>
template&lt;typename I , typename T , typename B , typename U &gt; </td></tr>
<tr class="memitem:a2d1ffcdcb56cdf9f4cb896b52d07a6c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_uninitialized_reduce</b> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, T *result, B bop, U uop)</td></tr>
<tr class="memdesc:a2d1ffcdcb56cdf9f4cb896b52d07a6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a9716ae4016ac058b32becef119faaddd" title="similar to tf::cudaFlow::transform_reduce but does not assume any initial value to reduce">tf::cudaFlow::transform_uninitialized_reduce</a> <br /></td></tr>
<tr class="separator:a2d1ffcdcb56cdf9f4cb896b52d07a6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062cc98a0b2d2199b50c3cbad16f5fb8" id="r_a062cc98a0b2d2199b50c3cbad16f5fb8"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a062cc98a0b2d2199b50c3cbad16f5fb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a062cc98a0b2d2199b50c3cbad16f5fb8">inclusive_scan</a> (I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a062cc98a0b2d2199b50c3cbad16f5fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to perform parallel inclusive scan over a range of items  <br /></td></tr>
<tr class="separator:a062cc98a0b2d2199b50c3cbad16f5fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ceb9d36d7e0ceeeb2acfdd6a2e6084" id="r_a98ceb9d36d7e0ceeeb2acfdd6a2e6084"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a98ceb9d36d7e0ceeeb2acfdd6a2e6084"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a98ceb9d36d7e0ceeeb2acfdd6a2e6084">inclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a98ceb9d36d7e0ceeeb2acfdd6a2e6084"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a062cc98a0b2d2199b50c3cbad16f5fb8" title="creates a task to perform parallel inclusive scan over a range of items">tf::cudaFlow::inclusive_scan</a>  <br /></td></tr>
<tr class="separator:a98ceb9d36d7e0ceeeb2acfdd6a2e6084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d59da7369a8634fea307219c7eb17c4" id="r_a8d59da7369a8634fea307219c7eb17c4"><td class="memTemplParams" colspan="2"><a id="a8d59da7369a8634fea307219c7eb17c4" name="a8d59da7369a8634fea307219c7eb17c4"></a>
template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a8d59da7369a8634fea307219c7eb17c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan</b> (I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a8d59da7369a8634fea307219c7eb17c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlow.html#a062cc98a0b2d2199b50c3cbad16f5fb8" title="creates a task to perform parallel inclusive scan over a range of items">cudaFlow::inclusive_scan</a> but excludes the first value <br /></td></tr>
<tr class="separator:a8d59da7369a8634fea307219c7eb17c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ff7124017ae5bc74ed7c6dc57988ed" id="r_a43ff7124017ae5bc74ed7c6dc57988ed"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a43ff7124017ae5bc74ed7c6dc57988ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a43ff7124017ae5bc74ed7c6dc57988ed">exclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a43ff7124017ae5bc74ed7c6dc57988ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a8d59da7369a8634fea307219c7eb17c4" title="similar to cudaFlow::inclusive_scan but excludes the first value">tf::cudaFlow::exclusive_scan</a>  <br /></td></tr>
<tr class="separator:a43ff7124017ae5bc74ed7c6dc57988ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5028579479a2393ce57ad37a7a809588" id="r_a5028579479a2393ce57ad37a7a809588"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:a5028579479a2393ce57ad37a7a809588"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a5028579479a2393ce57ad37a7a809588">transform_inclusive_scan</a> (I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:a5028579479a2393ce57ad37a7a809588"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to perform parallel inclusive scan over a range of transformed items  <br /></td></tr>
<tr class="separator:a5028579479a2393ce57ad37a7a809588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc38ad73ae8cb09cc743e08ad3a35c5f" id="r_abc38ad73ae8cb09cc743e08ad3a35c5f"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:abc38ad73ae8cb09cc743e08ad3a35c5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#abc38ad73ae8cb09cc743e08ad3a35c5f">transform_inclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:abc38ad73ae8cb09cc743e08ad3a35c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a5028579479a2393ce57ad37a7a809588" title="creates a task to perform parallel inclusive scan over a range of transformed items">tf::cudaFlow::transform_inclusive_scan</a>  <br /></td></tr>
<tr class="separator:abc38ad73ae8cb09cc743e08ad3a35c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80df494109b0dc6db77111917207e6b" id="r_ae80df494109b0dc6db77111917207e6b"><td class="memTemplParams" colspan="2"><a id="ae80df494109b0dc6db77111917207e6b" name="ae80df494109b0dc6db77111917207e6b"></a>
template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:ae80df494109b0dc6db77111917207e6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_exclusive_scan</b> (I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:ae80df494109b0dc6db77111917207e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlow.html#a5028579479a2393ce57ad37a7a809588" title="creates a task to perform parallel inclusive scan over a range of transformed items">cudaFlow::transform_inclusive_scan</a> but excludes the first value <br /></td></tr>
<tr class="separator:ae80df494109b0dc6db77111917207e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02568e834a18b703e9c8d0bc2dfd612c" id="r_a02568e834a18b703e9c8d0bc2dfd612c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:a02568e834a18b703e9c8d0bc2dfd612c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a02568e834a18b703e9c8d0bc2dfd612c">transform_exclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:a02568e834a18b703e9c8d0bc2dfd612c"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#ae80df494109b0dc6db77111917207e6b" title="similar to cudaFlow::transform_inclusive_scan but excludes the first value">tf::cudaFlow::transform_exclusive_scan</a>  <br /></td></tr>
<tr class="separator:a02568e834a18b703e9c8d0bc2dfd612c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fa5d69a57d010d7a3ee2756d85859c" id="r_af8fa5d69a57d010d7a3ee2756d85859c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename Comp &gt; </td></tr>
<tr class="memitem:af8fa5d69a57d010d7a3ee2756d85859c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#af8fa5d69a57d010d7a3ee2756d85859c">merge</a> (A a_first, A a_last, B b_first, B b_last, C c_first, Comp comp)</td></tr>
<tr class="memdesc:af8fa5d69a57d010d7a3ee2756d85859c"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to perform parallel merge on two sorted arrays  <br /></td></tr>
<tr class="separator:af8fa5d69a57d010d7a3ee2756d85859c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168006fd26cc40451978c6acd424504e" id="r_a168006fd26cc40451978c6acd424504e"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename Comp &gt; </td></tr>
<tr class="memitem:a168006fd26cc40451978c6acd424504e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a168006fd26cc40451978c6acd424504e">merge</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, A a_first, A a_last, B b_first, B b_last, C c_first, Comp comp)</td></tr>
<tr class="memdesc:a168006fd26cc40451978c6acd424504e"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#af8fa5d69a57d010d7a3ee2756d85859c" title="creates a task to perform parallel merge on two sorted arrays">tf::cudaFlow::merge</a>  <br /></td></tr>
<tr class="separator:a168006fd26cc40451978c6acd424504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae462d455fed06dfcdbd1e25a2c9c5da6" id="r_ae462d455fed06dfcdbd1e25a2c9c5da6"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:ae462d455fed06dfcdbd1e25a2c9c5da6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#ae462d455fed06dfcdbd1e25a2c9c5da6">sort</a> (I first, I last, C comp)</td></tr>
<tr class="memdesc:ae462d455fed06dfcdbd1e25a2c9c5da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to perform parallel sort an array  <br /></td></tr>
<tr class="separator:ae462d455fed06dfcdbd1e25a2c9c5da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63109604cb3df8644aa6db244dec3252" id="r_a63109604cb3df8644aa6db244dec3252"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a63109604cb3df8644aa6db244dec3252"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a63109604cb3df8644aa6db244dec3252">sort</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, C comp)</td></tr>
<tr class="memdesc:a63109604cb3df8644aa6db244dec3252"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of the task created from <a class="el" href="classtf_1_1cudaFlow.html#ae462d455fed06dfcdbd1e25a2c9c5da6" title="creates a task to perform parallel sort an array">tf::cudaFlow::sort</a>  <br /></td></tr>
<tr class="separator:a63109604cb3df8644aa6db244dec3252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979739fcf70fbd760ad1a7682a8dfea8" id="r_a979739fcf70fbd760ad1a7682a8dfea8"><td class="memTemplParams" colspan="2">template&lt;typename K_it , typename V_it , typename C &gt; </td></tr>
<tr class="memitem:a979739fcf70fbd760ad1a7682a8dfea8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a979739fcf70fbd760ad1a7682a8dfea8">sort_by_key</a> (K_it k_first, K_it k_last, V_it v_first, C comp)</td></tr>
<tr class="memdesc:a979739fcf70fbd760ad1a7682a8dfea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates kernels that sort the given array  <br /></td></tr>
<tr class="separator:a979739fcf70fbd760ad1a7682a8dfea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca349d0eece79a507a1e046e22ddc4a" id="r_abca349d0eece79a507a1e046e22ddc4a"><td class="memTemplParams" colspan="2">template&lt;typename K_it , typename V_it , typename C &gt; </td></tr>
<tr class="memitem:abca349d0eece79a507a1e046e22ddc4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#abca349d0eece79a507a1e046e22ddc4a">sort_by_key</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, K_it k_first, K_it k_last, V_it v_first, C comp)</td></tr>
<tr class="memdesc:abca349d0eece79a507a1e046e22ddc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a979739fcf70fbd760ad1a7682a8dfea8" title="creates kernels that sort the given array">tf::cudaFlow::sort_by_key</a>  <br /></td></tr>
<tr class="separator:abca349d0eece79a507a1e046e22ddc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdfde0bafee035c0075619d386a9a43" id="r_a9cdfde0bafee035c0075619d386a9a43"><td class="memTemplParams" colspan="2">template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </td></tr>
<tr class="memitem:a9cdfde0bafee035c0075619d386a9a43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a9cdfde0bafee035c0075619d386a9a43">merge_by_key</a> (a_keys_it a_keys_first, a_keys_it a_keys_last, a_vals_it a_vals_first, b_keys_it b_keys_first, b_keys_it b_keys_last, b_vals_it b_vals_first, c_keys_it c_keys_first, c_vals_it c_vals_first, C comp)</td></tr>
<tr class="memdesc:a9cdfde0bafee035c0075619d386a9a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to perform parallel key-value merge  <br /></td></tr>
<tr class="separator:a9cdfde0bafee035c0075619d386a9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7293eecb0bfffcd59ce64da19865c4" id="r_a1a7293eecb0bfffcd59ce64da19865c4"><td class="memTemplParams" colspan="2">template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </td></tr>
<tr class="memitem:a1a7293eecb0bfffcd59ce64da19865c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a1a7293eecb0bfffcd59ce64da19865c4">merge_by_key</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, a_keys_it a_keys_first, a_keys_it a_keys_last, a_vals_it a_vals_first, b_keys_it b_keys_first, b_keys_it b_keys_last, b_vals_it b_vals_first, c_keys_it c_keys_first, c_vals_it c_vals_first, C comp)</td></tr>
<tr class="memdesc:a1a7293eecb0bfffcd59ce64da19865c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a9cdfde0bafee035c0075619d386a9a43" title="creates a task to perform parallel key-value merge">tf::cudaFlow::merge_by_key</a>  <br /></td></tr>
<tr class="separator:a1a7293eecb0bfffcd59ce64da19865c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4812f4eccece9217da13dbc09992670c" id="r_a4812f4eccece9217da13dbc09992670c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename U &gt; </td></tr>
<tr class="memitem:a4812f4eccece9217da13dbc09992670c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a4812f4eccece9217da13dbc09992670c">find_if</a> (I first, I last, unsigned *idx, U op)</td></tr>
<tr class="memdesc:a4812f4eccece9217da13dbc09992670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to find the index of the first element in a range  <br /></td></tr>
<tr class="separator:a4812f4eccece9217da13dbc09992670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ea1f440e929924a7137a85661b962d" id="r_a25ea1f440e929924a7137a85661b962d"><td class="memTemplParams" colspan="2"><a id="a25ea1f440e929924a7137a85661b962d" name="a25ea1f440e929924a7137a85661b962d"></a>
template&lt;typename I , typename U &gt; </td></tr>
<tr class="memitem:a25ea1f440e929924a7137a85661b962d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if</b> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, unsigned *idx, U op)</td></tr>
<tr class="memdesc:a25ea1f440e929924a7137a85661b962d"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of the task created from <a class="el" href="classtf_1_1cudaFlow.html#a4812f4eccece9217da13dbc09992670c" title="creates a task to find the index of the first element in a range">tf::cudaFlow::find_if</a> <br /></td></tr>
<tr class="separator:a25ea1f440e929924a7137a85661b962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d18c5a42bb351fda43305258f51262" id="r_a63d18c5a42bb351fda43305258f51262"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a63d18c5a42bb351fda43305258f51262"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a63d18c5a42bb351fda43305258f51262">min_element</a> (I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:a63d18c5a42bb351fda43305258f51262"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the index of the minimum element in a range  <br /></td></tr>
<tr class="separator:a63d18c5a42bb351fda43305258f51262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae880febb9f5928d42455707f13bd9e9e" id="r_ae880febb9f5928d42455707f13bd9e9e"><td class="memTemplParams" colspan="2"><a id="ae880febb9f5928d42455707f13bd9e9e" name="ae880febb9f5928d42455707f13bd9e9e"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ae880febb9f5928d42455707f13bd9e9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min_element</b> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:ae880febb9f5928d42455707f13bd9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of the task created from <a class="el" href="classtf_1_1cudaFlow.html#a63d18c5a42bb351fda43305258f51262" title="finds the index of the minimum element in a range">tf::cudaFlow::min_element</a> <br /></td></tr>
<tr class="separator:ae880febb9f5928d42455707f13bd9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c99f8f1a961a225e2ea708afaa34905" id="r_a7c99f8f1a961a225e2ea708afaa34905"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a7c99f8f1a961a225e2ea708afaa34905"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a7c99f8f1a961a225e2ea708afaa34905">max_element</a> (I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:a7c99f8f1a961a225e2ea708afaa34905"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the index of the maximum element in a range  <br /></td></tr>
<tr class="separator:a7c99f8f1a961a225e2ea708afaa34905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05593150085596723ee87f9ed1c4bc3e" id="r_a05593150085596723ee87f9ed1c4bc3e"><td class="memTemplParams" colspan="2"><a id="a05593150085596723ee87f9ed1c4bc3e" name="a05593150085596723ee87f9ed1c4bc3e"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a05593150085596723ee87f9ed1c4bc3e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max_element</b> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:a05593150085596723ee87f9ed1c4bc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of the task created from <a class="el" href="classtf_1_1cudaFlow.html#a7c99f8f1a961a225e2ea708afaa34905" title="finds the index of the maximum element in a range">tf::cudaFlow::max_element</a> <br /></td></tr>
<tr class="separator:a05593150085596723ee87f9ed1c4bc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c389fff64a16e5dd8c60875d3b514d" id="r_a89c389fff64a16e5dd8c60875d3b514d"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a89c389fff64a16e5dd8c60875d3b514d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#a89c389fff64a16e5dd8c60875d3b514d">capture</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a89c389fff64a16e5dd8c60875d3b514d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a subflow graph through <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a>  <br /></td></tr>
<tr class="separator:a89c389fff64a16e5dd8c60875d3b514d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f182dc0fa99bcc9118311925fddca5" id="r_aa0f182dc0fa99bcc9118311925fddca5"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aa0f182dc0fa99bcc9118311925fddca5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlow.html#aa0f182dc0fa99bcc9118311925fddca5">capture</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, C callable)</td></tr>
<tr class="memdesc:aa0f182dc0fa99bcc9118311925fddca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the captured child graph  <br /></td></tr>
<tr class="separator:aa0f182dc0fa99bcc9118311925fddca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a763b2f90bc53f92d680a635fe28e858e" id="r_a763b2f90bc53f92d680a635fe28e858e"><td class="memItemLeft" align="right" valign="top"><a id="a763b2f90bc53f92d680a635fe28e858e" name="a763b2f90bc53f92d680a635fe28e858e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Executor</b></td></tr>
<tr class="separator:a763b2f90bc53f92d680a635fe28e858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>class to create a cudaFlow task dependency graph </p>
<p>A cudaFlow is a high-level interface over CUDA <a class="el" href="classtf_1_1Graph.html" title="class to create a graph object">Graph</a> to perform GPU operations using the task dependency graph model. The class provides a set of methods for creating and launch different tasks on one or multiple CUDA devices, for instance, kernel tasks, data transfer tasks, and memory operation tasks. The following example creates a cudaFlow of two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Taskflow.html">tf::Taskflow</a> taskflow;</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Executor.html">tf::Executor</a> executor;</div>
<div class="line"> </div>
<div class="line">taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line">  <span class="comment">// create two kernel tasks</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task1 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(grid1, block1, shm_size1, kernel1, args1);</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task2 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(grid2, block2, shm_size2, kernel2, args2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// kernel1 runs before kernel2</span></div>
<div class="line">  task1.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(task2);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">executor.<a class="code hl_function" href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">run</a>(taskflow).wait();</div>
<div class="ttc" id="aclasstf_1_1Executor_html"><div class="ttname"><a href="classtf_1_1Executor.html">tf::Executor</a></div><div class="ttdoc">class to create an executor for running a taskflow graph</div><div class="ttdef"><b>Definition</b> executor.hpp:50</div></div>
<div class="ttc" id="aclasstf_1_1Executor_html_a519777f5783981d534e9e53b99712069"><div class="ttname"><a href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">tf::Executor::run</a></div><div class="ttdeci">tf::Future&lt; void &gt; run(Taskflow &amp;taskflow)</div><div class="ttdoc">runs a taskflow once</div><div class="ttdef"><b>Definition</b> executor.hpp:1573</div></div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html_a60d7a666cab71ecfa3010b2efb0d6b57"><div class="ttname"><a href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">tf::FlowBuilder::emplace</a></div><div class="ttdeci">Task emplace(C &amp;&amp;callable)</div><div class="ttdoc">creates a static task</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:742</div></div>
<div class="ttc" id="aclasstf_1_1Taskflow_html"><div class="ttname"><a href="classtf_1_1Taskflow.html">tf::Taskflow</a></div><div class="ttdoc">class to create a taskflow object</div><div class="ttdef"><b>Definition</b> core/taskflow.hpp:73</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html"><div class="ttname"><a href="classtf_1_1cudaFlow.html">tf::cudaFlow</a></div><div class="ttdoc">class to create a cudaFlow task dependency graph</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:56</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_aa6e734462c8b8d922f44e621f94b104c"><div class="ttname"><a href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">tf::cudaFlow::kernel</a></div><div class="ttdeci">cudaTask kernel(dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</div><div class="ttdoc">creates a kernel task</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1272</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html"><div class="ttname"><a href="classtf_1_1cudaTask.html">tf::cudaTask</a></div><div class="ttdoc">class to create a task handle over an internal node of a cudaFlow graph</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:65</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_abdd68287ec4dff4216af34d1db44d1b4"><div class="ttname"><a href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">tf::cudaTask::precede</a></div><div class="ttdeci">cudaTask &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:182</div></div>
</div><!-- fragment --><p>A cudaFlow is a task (<a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a>) created from <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> and will be run by <em>one</em> worker thread in the executor. That is, the callable that describes a cudaFlow will be executed sequentially. Inside a cudaFlow task, different GPU tasks (<a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a>) may run in parallel scheduled by the CUDA runtime.</p>
<p>Please refer to <a class="el" href="GPUTaskingcudaFlow.html">GPU Tasking (cudaFlow)</a> for details. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad4c3e001db151486c8479151a2108d37" name="ad4c3e001db151486c8479151a2108d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c3e001db151486c8479151a2108d37">&#9670;&#160;</a></span>cudaFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::cudaFlow::cudaFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs a standalone cudaFlow </p>
<p>A standalone cudaFlow does not go through any taskflow and can be run by the caller thread using explicit offload methods (e.g., <a class="el" href="classtf_1_1cudaFlow.html#a85789ed8a1f47704cf1f1a2b98969444" title="offloads the cudaFlow and executes it once">tf::cudaFlow::offload</a>). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a89c389fff64a16e5dd8c60875d3b514d" name="a89c389fff64a16e5dd8c60875d3b514d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c389fff64a16e5dd8c60875d3b514d">&#9670;&#160;</a></span>capture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::capture </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a subflow graph through <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::function&lt;void(tf::cudaFlowCapturer&amp;)&gt;</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>the callable to construct a capture flow</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>A captured subflow forms a sub-graph to the cudaFlow and can be used to capture custom (or third-party) kernels that cannot be directly constructed from the cudaFlow.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line">taskflow.emplace([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> my_kernel = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(my_arguments);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create a flow capturer to capture custom kernels</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> my_subflow = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a89c389fff64a16e5dd8c60875d3b514d">capture</a>([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; capturer){</div>
<div class="line">    capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){</div>
<div class="line">      invoke_custom_kernel_with_stream(stream, custom_arguments);</div>
<div class="line">    });</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  my_kernel.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(my_subflow);</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a></div><div class="ttdoc">class to create a cudaFlow graph using stream capture</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:57</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_ad0d937ae0d77239f148b66a77e35db41"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">tf::cudaFlowCapturer::on</a></div><div class="ttdeci">cudaTask on(C &amp;&amp;callable)</div><div class="ttdoc">captures a sequential CUDA operations from the given callable</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1105</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_a89c389fff64a16e5dd8c60875d3b514d"><div class="ttname"><a href="classtf_1_1cudaFlow.html#a89c389fff64a16e5dd8c60875d3b514d">tf::cudaFlow::capture</a></div><div class="ttdeci">cudaTask capture(C &amp;&amp;callable)</div><div class="ttdoc">constructs a subflow graph through tf::cudaFlowCapturer</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1582</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa0f182dc0fa99bcc9118311925fddca5" name="aa0f182dc0fa99bcc9118311925fddca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f182dc0fa99bcc9118311925fddca5">&#9670;&#160;</a></span>capture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::capture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the captured child graph </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a89c389fff64a16e5dd8c60875d3b514d" title="constructs a subflow graph through tf::cudaFlowCapturer">tf::cudaFlow::capture</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132ea46be697979903d784a70aeec45eb14ad" title="subflow (child graph) task type">tf::cudaTaskType::SUBFLOW</a>. The new captured graph must be topologically identical to the original captured graph. </p>

</div>
</div>
<a id="a6cf6ec1e85172fa99c16bf0beffc0562" name="a6cf6ec1e85172fa99c16bf0beffc0562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf6ec1e85172fa99c16bf0beffc0562">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a memcpy task to a copy task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f" title="creates a memcopy task that copies typed data">tf::cudaFlow::copy</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132eac5d10cc70cce96265c445f14e7f5aba4" title="memory copy task type">tf::cudaTaskType::MEMCPY</a>. The source/destination memory may have different address values but must be allocated from the same contexts as the original source/destination memory. </p>

</div>
</div>
<a id="af03e04771b655f9e629eb4c22e19b19f" name="af03e04771b655f9e629eb4c22e19b19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03e04771b655f9e629eb4c22e19b19f">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::copy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a memcopy task that copies typed data </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>element type (non-void)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>pointer to the target memory block </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">num</td><td>number of elements to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>A copy task transfers <code>num*sizeof(T)</code> bytes of data from a source location to a target location. Direction can be arbitrary among CPUs and GPUs. </p>

</div>
</div>
<a id="a43507f21eb9cb77667ffe0ac7e6ae635" name="a43507f21eb9cb77667ffe0ac7e6ae635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43507f21eb9cb77667ffe0ac7e6ae635">&#9670;&#160;</a></span>dump_native_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::dump_native_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumps the native CUDA graph into a DOT format through an output stream </p>
<p>The native CUDA graph may be different from the upper-level cudaFlow graph when flow capture is involved. </p>

</div>
</div>
<a id="a43ff7124017ae5bc74ed7c6dc57988ed" name="a43ff7124017ae5bc74ed7c6dc57988ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ff7124017ae5bc74ed7c6dc57988ed">&#9670;&#160;</a></span>exclusive_scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a8d59da7369a8634fea307219c7eb17c4" title="similar to cudaFlow::inclusive_scan but excludes the first value">tf::cudaFlow::exclusive_scan</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a8d59da7369a8634fea307219c7eb17c4" title="similar to cudaFlow::inclusive_scan but excludes the first value">tf::cudaFlow::exclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="a39ed97c9142959c73d4c25c34d71bd5e" name="a39ed97c9142959c73d4c25c34d71bd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ed97c9142959c73d4c25c34d71bd5e">&#9670;&#160;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a memset task to a fill task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a21d4447bc834f4d3e1bb4772c850d090" title="creates a memset task that fills a typed memory block with a value">tf::cudaFlow::fill</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132ea41d4dbfd78ceea21abb0ecb03c3cc921" title="memory set task type">tf::cudaTaskType::MEMSET</a>.</p>
<p>The source/destination memory may have different address values but must be allocated from the same contexts as the original source/destination memory. </p>

</div>
</div>
<a id="a21d4447bc834f4d3e1bb4772c850d090" name="a21d4447bc834f4d3e1bb4772c850d090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d4447bc834f4d3e1bb4772c850d090">&#9670;&#160;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::fill </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a memset task that fills a typed memory block with a value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>element type (size of <code>T</code> must be either 1, 2, or 4)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>pointer to the destination device memory area </td></tr>
    <tr><td class="paramname">value</td><td>value to fill for each element of type <code>T</code> </td></tr>
    <tr><td class="paramname">count</td><td>number of elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>A fill task fills the first <code>count</code> elements of type <code>T</code> with <code>value</code> in a device memory area pointed by <code>dst</code>. The value to fill is interpreted in type <code>T</code> rather than byte. </p>

</div>
</div>
<a id="a4812f4eccece9217da13dbc09992670c" name="a4812f4eccece9217da13dbc09992670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4812f4eccece9217da13dbc09992670c">&#9670;&#160;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::find_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to find the index of the first element in a range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">U</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the range </td></tr>
    <tr><td class="paramname">idx</td><td>pointer to the index of the found element </td></tr>
    <tr><td class="paramname">op</td><td>unary operator which returns <code>true</code> for the required element</td></tr>
  </table>
  </dd>
</dl>
<p>Finds the index <code>idx</code> of the first element in the range <code>[first, last)</code> such that <code>op(*(first+idx))</code> is true. This is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> idx = 0;</div>
<div class="line"><span class="keywordflow">for</span>(; first != last; ++first, ++idx) {</div>
<div class="line">  <span class="keywordflow">if</span> (p(*first)) {</div>
<div class="line">    <span class="keywordflow">return</span> idx;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> idx;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af9cc7ee16602754929bb9118a9d7f0b2" name="af9cc7ee16602754929bb9118a9d7f0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cc7ee16602754929bb9118a9d7f0b2">&#9670;&#160;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::for_each </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a1a681f6223853b6445dcfdad07e4d0fd" title="applies a callable to each dereferenced element of the data array">tf::cudaFlow::for_each</a> </p>
<p>The type of the iterators and the callable must be the same as the task created from <a class="el" href="classtf_1_1cudaFlow.html#a1a681f6223853b6445dcfdad07e4d0fd" title="applies a callable to each dereferenced element of the data array">tf::cudaFlow::for_each</a>. </p>

</div>
</div>
<a id="a1a681f6223853b6445dcfdad07e4d0fd" name="a1a681f6223853b6445dcfdad07e4d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a681f6223853b6445dcfdad07e4d0fd">&#9670;&#160;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::for_each </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applies a callable to each dereferenced element of the data array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>iterator type </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive) </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to apply to the dereferenced iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> itr = first; itr != last; itr++) {</div>
<div class="line">  callable(*itr);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3fa7f8e38b4da1fe0cbcfb265f9349a2" name="a3fa7f8e38b4da1fe0cbcfb265f9349a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa7f8e38b4da1fe0cbcfb265f9349a2">&#9670;&#160;</a></span>for_each_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::for_each_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a34f1ea89e5651faa6e8af522a42556ac" title="applies a callable to each index in the range with the step size">tf::cudaFlow::for_each_index</a> </p>
<p>The type of the iterators and the callable must be the same as the task created from <a class="el" href="classtf_1_1cudaFlow.html#a34f1ea89e5651faa6e8af522a42556ac" title="applies a callable to each index in the range with the step size">tf::cudaFlow::for_each_index</a>. </p>

</div>
</div>
<a id="a34f1ea89e5651faa6e8af522a42556ac" name="a34f1ea89e5651faa6e8af522a42556ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f1ea89e5651faa6e8af522a42556ac">&#9670;&#160;</a></span>for_each_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::for_each_index </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applies a callable to each index in the range with the step size </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>index type </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>beginning index </td></tr>
    <tr><td class="paramname">last</td><td>last index </td></tr>
    <tr><td class="paramname">step</td><td>step size </td></tr>
    <tr><td class="paramname">callable</td><td>the callable to apply to each element in the data array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="comment">// step is positive [first, last)</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i=first; i&lt;last; i+=step) {</div>
<div class="line">  callable(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step is negative [first, last)</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i=first; i&gt;last; i+=step) {</div>
<div class="line">  callable(i);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a060e1c96111c2134ce0f896420a42cd0" name="a060e1c96111c2134ce0f896420a42cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060e1c96111c2134ce0f896420a42cd0">&#9670;&#160;</a></span>host() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::host </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a host task that runs a callable on the host </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>a callable object with neither arguments nor return (i.e., constructible from <code>std::function&lt;void()&gt;</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>A host task can only execute CPU-specific functions and cannot do any CUDA calls (e.g., <code>cudaMalloc</code>). </p>

</div>
</div>
<a id="a02e4e5cf7d03b9d087d6fbf54eb86bbf" name="a02e4e5cf7d03b9d087d6fbf54eb86bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e4e5cf7d03b9d087d6fbf54eb86bbf">&#9670;&#160;</a></span>host() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::host </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a host task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a060e1c96111c2134ce0f896420a42cd0" title="creates a host task that runs a callable on the host">tf::cudaFlow::host</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132eab9361011891280a44d85b967739cc6a5" title="host task type">tf::cudaTaskType::HOST</a>. </p>

</div>
</div>
<a id="a98ceb9d36d7e0ceeeb2acfdd6a2e6084" name="a98ceb9d36d7e0ceeeb2acfdd6a2e6084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ceb9d36d7e0ceeeb2acfdd6a2e6084">&#9670;&#160;</a></span>inclusive_scan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a062cc98a0b2d2199b50c3cbad16f5fb8" title="creates a task to perform parallel inclusive scan over a range of items">tf::cudaFlow::inclusive_scan</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a062cc98a0b2d2199b50c3cbad16f5fb8" title="creates a task to perform parallel inclusive scan over a range of items">tf::cudaFlow::inclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="a062cc98a0b2d2199b50c3cbad16f5fb8" name="a062cc98a0b2d2199b50c3cbad16f5fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062cc98a0b2d2199b50c3cbad16f5fb8">&#9670;&#160;</a></span>inclusive_scan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to perform parallel inclusive scan over a range of items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>binary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output </td></tr>
    <tr><td class="paramname">op</td><td>binary operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, last); i++) {</div>
<div class="line">  *(output + i) = i ? op(*(first+i), *(output+i-1)) : *(first+i);</div>
<div class="line">}</div>
<div class="ttc" id="adistance_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a></div><div class="ttdeci">T distance(T... args)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6ee746bd98fbb04326d1e76dab9b955c" name="a6ee746bd98fbb04326d1e76dab9b955c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee746bd98fbb04326d1e76dab9b955c">&#9670;&#160;</a></span>kernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::kernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a kernel task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c" title="creates a kernel task">tf::cudaFlow::kernel</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132ea35c10219c45ccfb5b07444fd7e17214c" title="memory copy task type">tf::cudaTaskType::KERNEL</a>. The kernel function name must NOT change. </p>

</div>
</div>
<a id="aa6e734462c8b8d922f44e621f94b104c" name="aa6e734462c8b8d922f44e621f94b104c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e734462c8b8d922f44e621f94b104c">&#9670;&#160;</a></span>kernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::kernel </td>
          <td>(</td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a kernel task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>kernel function type </td></tr>
    <tr><td class="paramname">ArgsT</td><td>kernel function parameters type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>configured grid </td></tr>
    <tr><td class="paramname">b</td><td>configured block </td></tr>
    <tr><td class="paramname">s</td><td>configured shared memory size in bytes </td></tr>
    <tr><td class="paramname">f</td><td>kernel function </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the kernel function by copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle </dd></dl>

</div>
</div>
<a id="a7c99f8f1a961a225e2ea708afaa34905" name="a7c99f8f1a961a225e2ea708afaa34905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c99f8f1a961a225e2ea708afaa34905">&#9670;&#160;</a></span>max_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::max_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the index of the maximum element in a range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the range </td></tr>
    <tr><td class="paramname">idx</td><td>solution index of the maximum element </td></tr>
    <tr><td class="paramname">op</td><td>comparison function object</td></tr>
  </table>
  </dd>
</dl>
<p>The function launches kernels asynchronously to find the largest element in the range <code>[first, last)</code> using the given comparator <code>op</code>. The function is equivalent to a parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(first == last) {</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> largest = first;</div>
<div class="line"><span class="keywordflow">for</span> (++first; first != last; ++first) {</div>
<div class="line">  <span class="keywordflow">if</span> (op(*largest, *first)) {</div>
<div class="line">    largest = first;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, largest);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acf9e6cfa65cbfcd1d33c88e64b487ce6" name="acf9e6cfa65cbfcd1d33c88e64b487ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9e6cfa65cbfcd1d33c88e64b487ce6">&#9670;&#160;</a></span>memcpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates parameters of a memcpy task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#ad37637606f0643f360e9eda1f9a6e559" title="creates a memcpy task that copies untyped data in bytes">tf::cudaFlow::memcpy</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132eac5d10cc70cce96265c445f14e7f5aba4" title="memory copy task type">tf::cudaTaskType::MEMCPY</a>. The source/destination memory may have different address values but must be allocated from the same contexts as the original source/destination memory. </p>

</div>
</div>
<a id="ad37637606f0643f360e9eda1f9a6e559" name="ad37637606f0643f360e9eda1f9a6e559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37637606f0643f360e9eda1f9a6e559">&#9670;&#160;</a></span>memcpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a memcpy task that copies untyped data in bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>pointer to the target memory block </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">bytes</td><td>bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>A memcpy task transfers <code>bytes</code> of data from a source location to a target location. Direction can be arbitrary among CPUs and GPUs. </p>

</div>
</div>
<a id="a082505f0fec89f65808421cdc737fb17" name="a082505f0fec89f65808421cdc737fb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082505f0fec89f65808421cdc737fb17">&#9670;&#160;</a></span>memset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates parameters of a memset task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a079ca65da35301e5aafd45878a19e9d2" title="creates a memset task that fills untyped data with a byte value">tf::cudaFlow::memset</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132ea41d4dbfd78ceea21abb0ecb03c3cc921" title="memory set task type">tf::cudaTaskType::MEMSET</a>. The source/destination memory may have different address values but must be allocated from the same contexts as the original source/destination memory. </p>

</div>
</div>
<a id="a079ca65da35301e5aafd45878a19e9d2" name="a079ca65da35301e5aafd45878a19e9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ca65da35301e5aafd45878a19e9d2">&#9670;&#160;</a></span>memset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a memset task that fills untyped data with a byte value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>pointer to the destination device memory area </td></tr>
    <tr><td class="paramname">v</td><td>value to set for each byte of specified memory </td></tr>
    <tr><td class="paramname">count</td><td>size in bytes to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>A memset task fills the first <code>count</code> bytes of device memory area pointed by <code>dst</code> with the byte value <code>v</code>. </p>

</div>
</div>
<a id="af8fa5d69a57d010d7a3ee2756d85859c" name="af8fa5d69a57d010d7a3ee2756d85859c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fa5d69a57d010d7a3ee2756d85859c">&#9670;&#160;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::merge </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to perform parallel merge on two sorted arrays </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>iterator type of the first input array </td></tr>
    <tr><td class="paramname">B</td><td>iterator type of the second input array </td></tr>
    <tr><td class="paramname">C</td><td>iterator type of the output array </td></tr>
    <tr><td class="paramname">Comp</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_first</td><td>iterator to the beginning of the first input array </td></tr>
    <tr><td class="paramname">a_last</td><td>iterator to the end of the first input array </td></tr>
    <tr><td class="paramname">b_first</td><td>iterator to the beginning of the second input array </td></tr>
    <tr><td class="paramname">b_last</td><td>iterator to the end of the second input array </td></tr>
    <tr><td class="paramname">c_first</td><td>iterator to the beginning of the output array </td></tr>
    <tr><td class="paramname">comp</td><td>binary comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>Merges two sorted ranges <code>[a_first, a_last)</code> and <code>[b_first, b_last)</code> into one sorted range beginning at <code>c_first</code>.</p>
<p>A sequence is said to be sorted with respect to a comparator <code>comp</code> if for any iterator it pointing to the sequence and any non-negative integer <code>n</code> such that <code>it + n</code> is a valid iterator pointing to an element of the sequence, <code>comp(*(it + n), *it)</code> evaluates to false. </p>

</div>
</div>
<a id="a168006fd26cc40451978c6acd424504e" name="a168006fd26cc40451978c6acd424504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168006fd26cc40451978c6acd424504e">&#9670;&#160;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#af8fa5d69a57d010d7a3ee2756d85859c" title="creates a task to perform parallel merge on two sorted arrays">tf::cudaFlow::merge</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#af8fa5d69a57d010d7a3ee2756d85859c" title="creates a task to perform parallel merge on two sorted arrays">tf::cudaFlow::merge</a> but operates on an existing task. </p>

</div>
</div>
<a id="a9cdfde0bafee035c0075619d386a9a43" name="a9cdfde0bafee035c0075619d386a9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdfde0bafee035c0075619d386a9a43">&#9670;&#160;</a></span>merge_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::merge_by_key </td>
          <td>(</td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_vals_it&#160;</td>
          <td class="paramname"><em>a_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_vals_it&#160;</td>
          <td class="paramname"><em>b_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_keys_it&#160;</td>
          <td class="paramname"><em>c_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vals_it&#160;</td>
          <td class="paramname"><em>c_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to perform parallel key-value merge </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">a_keys_it</td><td>first key iterator type </td></tr>
    <tr><td class="paramname">a_vals_it</td><td>first value iterator type </td></tr>
    <tr><td class="paramname">b_keys_it</td><td>second key iterator type </td></tr>
    <tr><td class="paramname">b_vals_it</td><td>second value iterator type </td></tr>
    <tr><td class="paramname">c_keys_it</td><td>output key iterator type </td></tr>
    <tr><td class="paramname">c_vals_it</td><td>output value iterator type </td></tr>
    <tr><td class="paramname">C</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_keys_first</td><td>iterator to the beginning of the first key range </td></tr>
    <tr><td class="paramname">a_keys_last</td><td>iterator to the end of the first key range </td></tr>
    <tr><td class="paramname">a_vals_first</td><td>iterator to the beginning of the first value range </td></tr>
    <tr><td class="paramname">b_keys_first</td><td>iterator to the beginning of the second key range </td></tr>
    <tr><td class="paramname">b_keys_last</td><td>iterator to the end of the second key range </td></tr>
    <tr><td class="paramname">b_vals_first</td><td>iterator to the beginning of the second value range </td></tr>
    <tr><td class="paramname">c_keys_first</td><td>iterator to the beginning of the output key range </td></tr>
    <tr><td class="paramname">c_vals_first</td><td>iterator to the beginning of the output value range </td></tr>
    <tr><td class="paramname">comp</td><td>comparator</td></tr>
  </table>
  </dd>
</dl>
<p>Performs a key-value merge that copies elements from <code>[a_keys_first, a_keys_last)</code> and <code>[b_keys_first, b_keys_last)</code> into a single range, <code>[c_keys_first, c_keys_last + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</code> such that the resulting range is in ascending key order.</p>
<p>At the same time, the merge copies elements from the two associated ranges <code>[a_vals_first + (a_keys_last - a_keys_first))</code> and <code>[b_vals_first + (b_keys_last - b_keys_first))</code> into a single range, <code>[c_vals_first, c_vals_first + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</code> such that the resulting range is in ascending order implied by each input element's associated key.</p>
<p>For example, assume:</p><ul>
<li><code>a_keys</code> = <code>{8, 1}</code></li>
<li><code>a_vals</code> = <code>{1, 2}</code></li>
<li><code>b_keys</code> = <code>{3, 7}</code></li>
<li><code>b_vals</code> = <code>{3, 4}</code></li>
</ul>
<p>After the merge, we have:</p><ul>
<li><code>c_keys</code> = <code>{1, 3, 7, 8}</code></li>
<li><code>c_vals</code> = <code>{2, 3, 4, 1}</code> </li>
</ul>

</div>
</div>
<a id="a1a7293eecb0bfffcd59ce64da19865c4" name="a1a7293eecb0bfffcd59ce64da19865c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7293eecb0bfffcd59ce64da19865c4">&#9670;&#160;</a></span>merge_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::merge_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_vals_it&#160;</td>
          <td class="paramname"><em>a_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_vals_it&#160;</td>
          <td class="paramname"><em>b_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_keys_it&#160;</td>
          <td class="paramname"><em>c_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vals_it&#160;</td>
          <td class="paramname"><em>c_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a9cdfde0bafee035c0075619d386a9a43" title="creates a task to perform parallel key-value merge">tf::cudaFlow::merge_by_key</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a9cdfde0bafee035c0075619d386a9a43" title="creates a task to perform parallel key-value merge">tf::cudaFlow::merge_by_key</a> but operates on an existing task. </p>

</div>
</div>
<a id="a63d18c5a42bb351fda43305258f51262" name="a63d18c5a42bb351fda43305258f51262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d18c5a42bb351fda43305258f51262">&#9670;&#160;</a></span>min_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::min_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the index of the minimum element in a range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the range </td></tr>
    <tr><td class="paramname">idx</td><td>solution index of the minimum element </td></tr>
    <tr><td class="paramname">op</td><td>comparison function object</td></tr>
  </table>
  </dd>
</dl>
<p>The function launches kernels asynchronously to find the smallest element in the range <code>[first, last)</code> using the given comparator <code>op</code>. The function is equivalent to a parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(first == last) {</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> smallest = first;</div>
<div class="line"><span class="keywordflow">for</span> (++first; first != last; ++first) {</div>
<div class="line">  <span class="keywordflow">if</span> (op(*first, *smallest)) {</div>
<div class="line">    smallest = first;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, smallest);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a30b2e107cb2c90a37f467b28d1b42a74" name="a30b2e107cb2c90a37f467b28d1b42a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b2e107cb2c90a37f467b28d1b42a74">&#9670;&#160;</a></span>noop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::noop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a no-operation task </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>An empty node performs no operation during execution, but can be used for transitive ordering. For example, a phased execution graph with 2 groups of <code>n</code> nodes with a barrier between them can be represented using an empty node and <code>2*n</code> dependency edges, rather than no empty node and <code>n^2</code> dependency edges. </p>

</div>
</div>
<a id="ac2269fd7dc8ca04a294a718204703dad" name="ac2269fd7dc8ca04a294a718204703dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2269fd7dc8ca04a294a718204703dad">&#9670;&#160;</a></span>offload_n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::offload_n </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>offloads the cudaFlow and executes it by the given times </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>number of executions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99358da15e3bdfa1faabb3e326130e1f" name="a99358da15e3bdfa1faabb3e326130e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99358da15e3bdfa1faabb3e326130e1f">&#9670;&#160;</a></span>offload_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::offload_until </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>offloads the cudaFlow onto a GPU and repeatedly runs it until the predicate becomes true </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>predicate type (a binary callable)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>a binary predicate (returns <code>true</code> for stop)</td></tr>
  </table>
  </dd>
</dl>
<p>Immediately offloads the present cudaFlow onto a GPU and repeatedly runs it until the predicate returns <code>true</code>.</p>
<p>An offloaded cudaFlow forces the underlying graph to be instantiated. After the instantiation, you should not modify the graph topology but update node parameters.</p>
<p>By default, if users do not offload the cudaFlow, the executor will offload it once. </p>

</div>
</div>
<a id="a4b56bc5ec489f4ed0da2c2826f4e9345" name="a4b56bc5ec489f4ed0da2c2826f4e9345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b56bc5ec489f4ed0da2c2826f4e9345">&#9670;&#160;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a931a0f99034bccf377aea35e221f50bc" title="performs parallel reduction over a range of items">tf::cudaFlow::reduce</a> </p>
<p>The type of the iterators, result, and callable must be the same as the task created from <a class="el" href="classtf_1_1cudaFlow.html#a931a0f99034bccf377aea35e221f50bc" title="performs parallel reduction over a range of items">tf::cudaFlow::reduce</a>. </p>

</div>
</div>
<a id="a931a0f99034bccf377aea35e221f50bc" name="a931a0f99034bccf377aea35e221f50bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931a0f99034bccf377aea35e221f50bc">&#9670;&#160;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs parallel reduction over a range of items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">B</td><td>binary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive) </td></tr>
    <tr><td class="paramname">result</td><td>pointer to the result with an initialized value </td></tr>
    <tr><td class="paramname">bop</td><td>binary operator to apply to reduce items</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = bop(*result, *first++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac2906cb0002fc411a983d100a3d58d62" name="ac2906cb0002fc411a983d100a3d58d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2906cb0002fc411a983d100a3d58d62">&#9670;&#160;</a></span>single_task() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::single_task </td>
          <td>(</td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a callable with only a single kernel thread </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>callable to run by a single kernel thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle </dd></dl>

</div>
</div>
<a id="add2d364f38c72322d8e36bc0da0b98e4" name="add2d364f38c72322d8e36bc0da0b98e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2d364f38c72322d8e36bc0da0b98e4">&#9670;&#160;</a></span>single_task() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a single-threaded kernel task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#ac2906cb0002fc411a983d100a3d58d62" title="runs a callable with only a single kernel thread">cudaFlow::single_task</a> but operates on an existing task. </p>

</div>
</div>
<a id="a63109604cb3df8644aa6db244dec3252" name="a63109604cb3df8644aa6db244dec3252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63109604cb3df8644aa6db244dec3252">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of the task created from <a class="el" href="classtf_1_1cudaFlow.html#ae462d455fed06dfcdbd1e25a2c9c5da6" title="creates a task to perform parallel sort an array">tf::cudaFlow::sort</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#ae462d455fed06dfcdbd1e25a2c9c5da6" title="creates a task to perform parallel sort an array">tf::cudaFlow::sort</a> but operates on an existing task. </p>

</div>
</div>
<a id="ae462d455fed06dfcdbd1e25a2c9c5da6" name="ae462d455fed06dfcdbd1e25a2c9c5da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae462d455fed06dfcdbd1e25a2c9c5da6">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::sort </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to perform parallel sort an array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>iterator type of the first input array </td></tr>
    <tr><td class="paramname">C</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the input array </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the input array </td></tr>
    <tr><td class="paramname">comp</td><td>binary comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>Sorts elements in the range <code>[first, last)</code> with the given comparator <code>comp</code>. </p>

</div>
</div>
<a id="abca349d0eece79a507a1e046e22ddc4a" name="abca349d0eece79a507a1e046e22ddc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca349d0eece79a507a1e046e22ddc4a">&#9670;&#160;</a></span>sort_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K_it , typename V_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V_it&#160;</td>
          <td class="paramname"><em>v_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a979739fcf70fbd760ad1a7682a8dfea8" title="creates kernels that sort the given array">tf::cudaFlow::sort_by_key</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a979739fcf70fbd760ad1a7682a8dfea8" title="creates kernels that sort the given array">tf::cudaFlow::sort_by_key</a> but operates on an existing task. </p>

</div>
</div>
<a id="a979739fcf70fbd760ad1a7682a8dfea8" name="a979739fcf70fbd760ad1a7682a8dfea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979739fcf70fbd760ad1a7682a8dfea8">&#9670;&#160;</a></span>sort_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K_it , typename V_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V_it&#160;</td>
          <td class="paramname"><em>v_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates kernels that sort the given array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_it</td><td>iterator type of the key </td></tr>
    <tr><td class="paramname">V_it</td><td>iterator type of the value </td></tr>
    <tr><td class="paramname">C</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k_first</td><td>iterator to the beginning of the key array </td></tr>
    <tr><td class="paramname">k_last</td><td>iterator to the end of the key array </td></tr>
    <tr><td class="paramname">v_first</td><td>iterator to the beginning of the value array </td></tr>
    <tr><td class="paramname">comp</td><td>binary comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>Sorts key-value elements in <code>[k_first, k_last)</code> and <code>[v_first, v_first + (k_last - k_first))</code> into ascending key order using the given comparator <code>comp</code>. If <code>i</code> and <code>j</code> are any two valid iterators in <code>[k_first, k_last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[v_first, v_first + (k_last - k_first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>comp(*j, *i)</code> evaluates to <code>false</code>.</p>
<p>For example, assume:</p><ul>
<li><code>keys</code> are <code>{1, 4, 2, 8, 5, 7}</code></li>
<li><code>values</code> are <code>{'a', 'b', 'c', 'd', 'e', 'f'}</code></li>
</ul>
<p>After sort:</p><ul>
<li><code>keys</code> are <code>{1, 2, 4, 5, 7, 8}</code></li>
<li><code>values</code> are <code>{'a', 'c', 'b', 'e', 'f', 'd'}</code> </li>
</ul>

</div>
</div>
<a id="a4a211b1f8562e10f9aae8b44fd6acdec" name="a4a211b1f8562e10f9aae8b44fd6acdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a211b1f8562e10f9aae8b44fd6acdec">&#9670;&#160;</a></span>transform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#af89a9bda182272462a0eda2581536cd8" title="applies a callable to a source range and stores the result in a target range">tf::cudaFlow::transform</a> </p>
<p>The type of the iterators and the callable must be the same as the task created from <a class="el" href="classtf_1_1cudaFlow.html#a1a681f6223853b6445dcfdad07e4d0fd" title="applies a callable to each dereferenced element of the data array">tf::cudaFlow::for_each</a>. </p>

</div>
</div>
<a id="a7c6ca7be2b6908e8f71570c54303ba9e" name="a7c6ca7be2b6908e8f71570c54303ba9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6ca7be2b6908e8f71570c54303ba9e">&#9670;&#160;</a></span>transform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#af89a9bda182272462a0eda2581536cd8" title="applies a callable to a source range and stores the result in a target range">tf::cudaFlow::transform</a> </p>
<p>The type of the iterators and the callable must be the same as the task created from <a class="el" href="classtf_1_1cudaFlow.html#a1a681f6223853b6445dcfdad07e4d0fd" title="applies a callable to each dereferenced element of the data array">tf::cudaFlow::for_each</a>. </p>

</div>
</div>
<a id="af89a9bda182272462a0eda2581536cd8" name="af89a9bda182272462a0eda2581536cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89a9bda182272462a0eda2581536cd8">&#9670;&#160;</a></span>transform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::transform </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applies a callable to a source range and stores the result in a target range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the input range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the input range </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output range </td></tr>
    <tr><td class="paramname">op</td><td>the operator to apply to transform each element in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *output++ = callable(*first++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abab2bfdfc86ef3a764ece4743fdede76" name="abab2bfdfc86ef3a764ece4743fdede76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab2bfdfc86ef3a764ece4743fdede76">&#9670;&#160;</a></span>transform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::transform </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to perform parallel transforms over two ranges of items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I1</td><td>first input iterator type </td></tr>
    <tr><td class="paramname">I2</td><td>second input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>iterator to the beginning of the input range </td></tr>
    <tr><td class="paramname">last1</td><td>iterator to the end of the input range </td></tr>
    <tr><td class="paramname">first2</td><td>iterato </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output range </td></tr>
    <tr><td class="paramname">op</td><td>binary operator to apply to transform each pair of items in the two input ranges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first1 != last1) {</div>
<div class="line">  *output++ = op(*first1++, *first2++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a02568e834a18b703e9c8d0bc2dfd612c" name="a02568e834a18b703e9c8d0bc2dfd612c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02568e834a18b703e9c8d0bc2dfd612c">&#9670;&#160;</a></span>transform_exclusive_scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::transform_exclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#ae80df494109b0dc6db77111917207e6b" title="similar to cudaFlow::transform_inclusive_scan but excludes the first value">tf::cudaFlow::transform_exclusive_scan</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#ae80df494109b0dc6db77111917207e6b" title="similar to cudaFlow::transform_inclusive_scan but excludes the first value">tf::cudaFlow::transform_exclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="abc38ad73ae8cb09cc743e08ad3a35c5f" name="abc38ad73ae8cb09cc743e08ad3a35c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc38ad73ae8cb09cc743e08ad3a35c5f">&#9670;&#160;</a></span>transform_inclusive_scan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::transform_inclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a task created from <a class="el" href="classtf_1_1cudaFlow.html#a5028579479a2393ce57ad37a7a809588" title="creates a task to perform parallel inclusive scan over a range of transformed items">tf::cudaFlow::transform_inclusive_scan</a> </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a5028579479a2393ce57ad37a7a809588" title="creates a task to perform parallel inclusive scan over a range of transformed items">tf::cudaFlow::transform_inclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="a5028579479a2393ce57ad37a7a809588" name="a5028579479a2393ce57ad37a7a809588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5028579479a2393ce57ad37a7a809588">&#9670;&#160;</a></span>transform_inclusive_scan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::transform_inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to perform parallel inclusive scan over a range of transformed items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">B</td><td>binary operator type </td></tr>
    <tr><td class="paramname">U</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output </td></tr>
    <tr><td class="paramname">bop</td><td>binary operator </td></tr>
    <tr><td class="paramname">uop</td><td>unary operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, last); i++) {</div>
<div class="line">  *(output + i) = i ? op(uop(*(first+i)), *(output+i-1)) : uop(*(first+i));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1af5d4e8a3820f9b9d8abbe4f4f6c4a4" name="a1af5d4e8a3820f9b9d8abbe4f4f6c4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af5d4e8a3820f9b9d8abbe4f4f6c4a4">&#9670;&#160;</a></span>transform_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::transform_reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs parallel reduction over a range of transformed items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">B</td><td>binary operator type </td></tr>
    <tr><td class="paramname">U</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive) </td></tr>
    <tr><td class="paramname">result</td><td>pointer to the result with an initialized value </td></tr>
    <tr><td class="paramname">bop</td><td>binary operator to apply to reduce items </td></tr>
    <tr><td class="paramname">uop</td><td>unary operator to transform each item before reduction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = bop(*result, uop(*first++));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9716ae4016ac058b32becef119faaddd" name="a9716ae4016ac058b32becef119faaddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9716ae4016ac058b32becef119faaddd">&#9670;&#160;</a></span>transform_uninitialized_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::transform_uninitialized_reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to <a class="el" href="classtf_1_1cudaFlow.html#a1af5d4e8a3820f9b9d8abbe4f4f6c4a4" title="performs parallel reduction over a range of transformed items">tf::cudaFlow::transform_reduce</a> but does not assume any initial value to reduce </p>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line">*result = uop(*first++);  <span class="comment">// no initial values partitipcate in the loop</span></div>
<div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = bop(*result, uop(*first++));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a096b655c4d8c9a4d5d250cdce6a49c59" name="a096b655c4d8c9a4d5d250cdce6a49c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096b655c4d8c9a4d5d250cdce6a49c59">&#9670;&#160;</a></span>uninitialized_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::uninitialized_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a kernel task created from <a class="el" href="classtf_1_1cudaFlow.html#a3a5189b9c9494d2a63a983c32cf234f6" title="similar to tf::cudaFlow::reduce but does not assume any initial value to reduce">tf::cudaFlow::uninitialized_reduce</a> </p>
<p>The type of the iterators, result, and callable must be the same as the task created from <a class="el" href="classtf_1_1cudaFlow.html#a3a5189b9c9494d2a63a983c32cf234f6" title="similar to tf::cudaFlow::reduce but does not assume any initial value to reduce">tf::cudaFlow::uninitialized_reduce</a>. </p>

</div>
</div>
<a id="a3a5189b9c9494d2a63a983c32cf234f6" name="a3a5189b9c9494d2a63a983c32cf234f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5189b9c9494d2a63a983c32cf234f6">&#9670;&#160;</a></span>uninitialized_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::uninitialized_reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to <a class="el" href="classtf_1_1cudaFlow.html#a931a0f99034bccf377aea35e221f50bc" title="performs parallel reduction over a range of items">tf::cudaFlow::reduce</a> but does not assume any initial value to reduce </p>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line">*result = *first++;  <span class="comment">// no initial values partitipcate in the loop</span></div>
<div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = op(*result, *first++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a78c2a73243809e3cbd1955cc1ffe6477" name="a78c2a73243809e3cbd1955cc1ffe6477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c2a73243809e3cbd1955cc1ffe6477">&#9670;&#160;</a></span>zero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlow::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates parameters of a memset task to a zero task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b" title="creates a memset task that sets a typed memory block to zero">tf::cudaFlow::zero</a> but operates on a task of type <a class="el" href="namespacetf.html#afebc56ae6d5765010d0dd13a5f04132ea41d4dbfd78ceea21abb0ecb03c3cc921" title="memory set task type">tf::cudaTaskType::MEMSET</a>.</p>
<p>The source/destination memory may have different address values but must be allocated from the same contexts as the original source/destination memory. </p>

</div>
</div>
<a id="a40172fac4464f6d805f75921ea3c2a3b" name="a40172fac4464f6d805f75921ea3c2a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40172fac4464f6d805f75921ea3c2a3b">&#9670;&#160;</a></span>zero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlow::zero </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a memset task that sets a typed memory block to zero </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>element type (size of <code>T</code> must be either 1, 2, or 4) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>pointer to the destination device memory area </td></tr>
    <tr><td class="paramname">count</td><td>number of elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>A zero task zeroes the first <code>count</code> elements of type <code>T</code> in a device memory area pointed by <code>dst</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cudaflow_8hpp_source.html">cudaflow.hpp</a></li>
<li><a class="el" href="for__each_8hpp_source.html">for_each.hpp</a></li>
<li><a class="el" href="transform_8hpp_source.html">transform.hpp</a></li>
<li><a class="el" href="reduce_8hpp_source.html">reduce.hpp</a></li>
<li><a class="el" href="scan_8hpp_source.html">scan.hpp</a></li>
<li><a class="el" href="merge_8hpp_source.html">merge.hpp</a></li>
<li><a class="el" href="sort_8hpp_source.html">sort.hpp</a></li>
<li><a class="el" href="find_8hpp_source.html">find.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetf.html">tf</a></li><li class="navelem"><a class="el" href="classtf_1_1cudaFlow.html">cudaFlow</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
