<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Taskflow Handbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/x-icon" href="favicon.ico" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="taskflow_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://taskflow.github.io/">Taskflow</a>
   &#160;<span id="projectnumber">3.2.0-Master-Branch</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtf_1_1FlowBuilder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtf_1_1FlowBuilder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tf::FlowBuilder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>class to build a task dependency graph  
 <a href="classtf_1_1FlowBuilder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="flow__builder_8hpp_source.html">flow_builder.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tf::FlowBuilder:</div>
<div class="dyncontent">
<div class="center"><img src="classtf_1_1FlowBuilder__inherit__graph.png" border="0" usemap="#atf_1_1FlowBuilder_inherit__map" alt="Inheritance graph"/></div>
<map name="atf_1_1FlowBuilder_inherit__map" id="atf_1_1FlowBuilder_inherit__map">
<area shape="rect" title="class to build a task dependency graph" alt="" coords="62,5,220,40"/>
<area shape="rect" href="classtf_1_1Subflow.html" title="class to construct a subflow graph from the execution of a dynamic task" alt="" coords="5,88,128,123"/>
<area shape="poly" title=" " alt="" coords="119,52,84,90,80,86,115,48"/>
<area shape="rect" href="classtf_1_1Taskflow.html" title="class to create a taskflow object" alt="" coords="152,88,283,123"/>
<area shape="poly" title=" " alt="" coords="168,48,204,86,200,90,164,52"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tf::FlowBuilder:</div>
<div class="dyncontent">
<div class="center"><img src="classtf_1_1FlowBuilder__coll__graph.png" border="0" usemap="#atf_1_1FlowBuilder_coll__map" alt="Collaboration graph"/></div>
<map name="atf_1_1FlowBuilder_coll__map" id="atf_1_1FlowBuilder_coll__map">
<area shape="rect" title="class to build a task dependency graph" alt="" coords="5,112,163,147"/>
<area shape="rect" href="classtf_1_1Graph.html" title="class to create a graph object" alt="" coords="31,5,137,40"/>
<area shape="poly" title=" " alt="" coords="87,54,87,112,81,112,81,54"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67d023d5493da1594a1d2eaea89da179" id="r_a67d023d5493da1594a1d2eaea89da179"><td class="memItemLeft" align="right" valign="top"><a id="a67d023d5493da1594a1d2eaea89da179" name="a67d023d5493da1594a1d2eaea89da179"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FlowBuilder</b> (<a class="el" href="classtf_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a67d023d5493da1594a1d2eaea89da179"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a flow builder with a graph <br /></td></tr>
<tr class="separator:a67d023d5493da1594a1d2eaea89da179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57" id="r_a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a11fc9c98eb3a0d3a9aa55598b1f4d614">is_static_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a static task  <br /></td></tr>
<tr class="separator:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57" id="r_a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a1eea7593f25ab348cfb656dbdf4e5b05">is_dynamic_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a dynamic task  <br /></td></tr>
<tr class="separator:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57" id="r_a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df">is_condition_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a condition task  <br /></td></tr>
<tr class="separator:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57" id="r_a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a78c40dc8776735b0f2c27cd446481aff">is_multi_condition_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a multi-condition task  <br /></td></tr>
<tr class="separator:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6118326ad434f6c839007a1a79fe1b" id="r_a1f6118326ad434f6c839007a1a79fe1b"><td class="memTemplParams" colspan="2">template&lt;typename... C, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;(sizeof...(C)&gt;1), void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1f6118326ad434f6c839007a1a79fe1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a1f6118326ad434f6c839007a1a79fe1b">emplace</a> (C &amp;&amp;... callables)</td></tr>
<tr class="memdesc:a1f6118326ad434f6c839007a1a79fe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates multiple tasks from a list of callable objects  <br /></td></tr>
<tr class="separator:a1f6118326ad434f6c839007a1a79fe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5627f7962099ac7c4986993cffa7b909" id="r_a5627f7962099ac7c4986993cffa7b909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a5627f7962099ac7c4986993cffa7b909">erase</a> (<a class="el" href="classtf_1_1Task.html">Task</a> task)</td></tr>
<tr class="memdesc:a5627f7962099ac7c4986993cffa7b909"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes a task from a taskflow  <br /></td></tr>
<tr class="separator:a5627f7962099ac7c4986993cffa7b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f22228d4c2ea2e643c4b0d42c0e92a" id="r_ac6f22228d4c2ea2e643c4b0d42c0e92a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6f22228d4c2ea2e643c4b0d42c0e92a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#ac6f22228d4c2ea2e643c4b0d42c0e92a">composed_of</a> (T &amp;object)</td></tr>
<tr class="memdesc:ac6f22228d4c2ea2e643c4b0d42c0e92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a module task for the target object  <br /></td></tr>
<tr class="separator:ac6f22228d4c2ea2e643c4b0d42c0e92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab0b4ac82260f47fdb36a3244ee3aaf" id="r_acab0b4ac82260f47fdb36a3244ee3aaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#acab0b4ac82260f47fdb36a3244ee3aaf">placeholder</a> ()</td></tr>
<tr class="memdesc:acab0b4ac82260f47fdb36a3244ee3aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a placeholder task  <br /></td></tr>
<tr class="separator:acab0b4ac82260f47fdb36a3244ee3aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57" id="r_a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0">is_cudaflow_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a cudaFlow task on the caller's GPU device context  <br /></td></tr>
<tr class="separator:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf47fd1a358fb64f8c1b89e2a393169" id="r_afdf47fd1a358fb64f8c1b89e2a393169"><td class="memTemplParams" colspan="2">template&lt;typename C , typename D , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0">is_cudaflow_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afdf47fd1a358fb64f8c1b89e2a393169"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#afdf47fd1a358fb64f8c1b89e2a393169">emplace_on</a> (C &amp;&amp;callable, D &amp;&amp;device)</td></tr>
<tr class="memdesc:afdf47fd1a358fb64f8c1b89e2a393169"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a cudaFlow task on the given device  <br /></td></tr>
<tr class="separator:afdf47fd1a358fb64f8c1b89e2a393169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57" id="r_a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf">is_syclflow_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a syclFlow task on the default queue  <br /></td></tr>
<tr class="separator:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c878fa6f0c4539ab88c0a85e6052d8" id="r_af7c878fa6f0c4539ab88c0a85e6052d8"><td class="memTemplParams" colspan="2">template&lt;typename C , typename Q , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf">is_syclflow_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af7c878fa6f0c4539ab88c0a85e6052d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#af7c878fa6f0c4539ab88c0a85e6052d8">emplace_on</a> (C &amp;&amp;callable, Q &amp;&amp;queue)</td></tr>
<tr class="memdesc:af7c878fa6f0c4539ab88c0a85e6052d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a syclFlow task on the given queue  <br /></td></tr>
<tr class="separator:af7c878fa6f0c4539ab88c0a85e6052d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57" id="r_a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#af3d94f0be0f7b49e195c4e92737b1f85">is_runtime_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a runtime task  <br /></td></tr>
<tr class="separator:a60d7a666cab71ecfa3010b2efb0d6b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f3d9b9d6fcf4df8e7d7878dfdd130d" id="r_a90f3d9b9d6fcf4df8e7d7878dfdd130d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a90f3d9b9d6fcf4df8e7d7878dfdd130d">linearize</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classtf_1_1Task.html">Task</a> &gt; &amp;tasks)</td></tr>
<tr class="memdesc:a90f3d9b9d6fcf4df8e7d7878dfdd130d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds adjacent dependency links to a linear list of tasks  <br /></td></tr>
<tr class="separator:a90f3d9b9d6fcf4df8e7d7878dfdd130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec89b554d15ad5fb96f4fdb10dbbb16" id="r_a4ec89b554d15ad5fb96f4fdb10dbbb16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a4ec89b554d15ad5fb96f4fdb10dbbb16">linearize</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classtf_1_1Task.html">Task</a> &gt; tasks)</td></tr>
<tr class="memdesc:a4ec89b554d15ad5fb96f4fdb10dbbb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds adjacent dependency links to a linear list of tasks  <br /></td></tr>
<tr class="separator:a4ec89b554d15ad5fb96f4fdb10dbbb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab405d7b10040530d8b04c11767b4960d" id="r_ab405d7b10040530d8b04c11767b4960d"><td class="memTemplParams" colspan="2">template&lt;typename B , typename E , typename C &gt; </td></tr>
<tr class="memitem:ab405d7b10040530d8b04c11767b4960d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#ab405d7b10040530d8b04c11767b4960d">for_each</a> (B first, E last, C callable)</td></tr>
<tr class="memdesc:ab405d7b10040530d8b04c11767b4960d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a STL-styled parallel-for task  <br /></td></tr>
<tr class="separator:ab405d7b10040530d8b04c11767b4960d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ffe176bc3ae1827b9964322e3769d4" id="r_a38ffe176bc3ae1827b9964322e3769d4"><td class="memTemplParams" colspan="2">template&lt;typename B , typename E , typename S , typename C &gt; </td></tr>
<tr class="memitem:a38ffe176bc3ae1827b9964322e3769d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a38ffe176bc3ae1827b9964322e3769d4">for_each_index</a> (B first, E last, S step, C callable)</td></tr>
<tr class="memdesc:a38ffe176bc3ae1827b9964322e3769d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a parallel-transform task  <br /></td></tr>
<tr class="separator:a38ffe176bc3ae1827b9964322e3769d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd813bd7afcbd8e6f56dc67883917d1a" id="r_abd813bd7afcbd8e6f56dc67883917d1a"><td class="memTemplParams" colspan="2">template&lt;typename B , typename E , typename O , typename C &gt; </td></tr>
<tr class="memitem:abd813bd7afcbd8e6f56dc67883917d1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#abd813bd7afcbd8e6f56dc67883917d1a">transform</a> (B first1, E last1, O d_first, C c)</td></tr>
<tr class="memdesc:abd813bd7afcbd8e6f56dc67883917d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a parallel-transform task  <br /></td></tr>
<tr class="separator:abd813bd7afcbd8e6f56dc67883917d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b3271b34317710a1e32053a9abc3cf" id="r_aa0b3271b34317710a1e32053a9abc3cf"><td class="memTemplParams" colspan="2">template&lt;typename B1 , typename E1 , typename B2 , typename O , typename C &gt; </td></tr>
<tr class="memitem:aa0b3271b34317710a1e32053a9abc3cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#aa0b3271b34317710a1e32053a9abc3cf">transform</a> (B1 first1, E1 last1, B2 first2, O d_first, C c)</td></tr>
<tr class="memdesc:aa0b3271b34317710a1e32053a9abc3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a parallel-transform task  <br /></td></tr>
<tr class="separator:aa0b3271b34317710a1e32053a9abc3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9494fe7b862fc832884ce318e8a37f5" id="r_aa9494fe7b862fc832884ce318e8a37f5"><td class="memTemplParams" colspan="2">template&lt;typename B , typename E , typename T , typename O &gt; </td></tr>
<tr class="memitem:aa9494fe7b862fc832884ce318e8a37f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#aa9494fe7b862fc832884ce318e8a37f5">reduce</a> (B first, E last, T &amp;init, O bop)</td></tr>
<tr class="memdesc:aa9494fe7b862fc832884ce318e8a37f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a STL-styled parallel-reduce task  <br /></td></tr>
<tr class="separator:aa9494fe7b862fc832884ce318e8a37f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a1e5b4f138b6caebb427411fb0a2d" id="r_a024a1e5b4f138b6caebb427411fb0a2d"><td class="memTemplParams" colspan="2">template&lt;typename B , typename E , typename T , typename BOP , typename UOP &gt; </td></tr>
<tr class="memitem:a024a1e5b4f138b6caebb427411fb0a2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a024a1e5b4f138b6caebb427411fb0a2d">transform_reduce</a> (B first, E last, T &amp;init, BOP bop, UOP uop)</td></tr>
<tr class="memdesc:a024a1e5b4f138b6caebb427411fb0a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a STL-styled parallel transform-reduce task  <br /></td></tr>
<tr class="separator:a024a1e5b4f138b6caebb427411fb0a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e180eb63de6c9f28e43185e837a4fa" id="r_a35e180eb63de6c9f28e43185e837a4fa"><td class="memTemplParams" colspan="2">template&lt;typename B , typename E , typename C &gt; </td></tr>
<tr class="memitem:a35e180eb63de6c9f28e43185e837a4fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a35e180eb63de6c9f28e43185e837a4fa">sort</a> (B first, E last, C cmp)</td></tr>
<tr class="memdesc:a35e180eb63de6c9f28e43185e837a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a dynamic task to perform STL-styled parallel sort  <br /></td></tr>
<tr class="separator:a35e180eb63de6c9f28e43185e837a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d844e9856c7c65b26ccdb83ffdab1d6" id="r_a7d844e9856c7c65b26ccdb83ffdab1d6"><td class="memTemplParams" colspan="2">template&lt;typename B , typename E &gt; </td></tr>
<tr class="memitem:a7d844e9856c7c65b26ccdb83ffdab1d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1FlowBuilder.html#a7d844e9856c7c65b26ccdb83ffdab1d6">sort</a> (B first, E last)</td></tr>
<tr class="memdesc:a7d844e9856c7c65b26ccdb83ffdab1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a dynamic task to perform STL-styled parallel sort using the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::less&lt;T&gt;</a></code> comparator, where <code>T</code> is the element type  <br /></td></tr>
<tr class="separator:a7d844e9856c7c65b26ccdb83ffdab1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9404a57d9d37a4d49d20b686e4e5f68f" id="r_a9404a57d9d37a4d49d20b686e4e5f68f"><td class="memItemLeft" align="right" valign="top"><a id="a9404a57d9d37a4d49d20b686e4e5f68f" name="a9404a57d9d37a4d49d20b686e4e5f68f"></a>
<a class="el" href="classtf_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_graph</b></td></tr>
<tr class="memdesc:a9404a57d9d37a4d49d20b686e4e5f68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">associated graph object <br /></td></tr>
<tr class="separator:a9404a57d9d37a4d49d20b686e4e5f68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a763b2f90bc53f92d680a635fe28e858e" id="r_a763b2f90bc53f92d680a635fe28e858e"><td class="memItemLeft" align="right" valign="top"><a id="a763b2f90bc53f92d680a635fe28e858e" name="a763b2f90bc53f92d680a635fe28e858e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Executor</b></td></tr>
<tr class="separator:a763b2f90bc53f92d680a635fe28e858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>class to build a task dependency graph </p>
<p>The class provides essential methods to construct a task dependency graph from which <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> and <a class="el" href="classtf_1_1Subflow.html" title="class to construct a subflow graph from the execution of a dynamic task">tf::Subflow</a> are derived. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac6f22228d4c2ea2e643c4b0d42c0e92a" name="ac6f22228d4c2ea2e643c4b0d42c0e92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f22228d4c2ea2e643c4b0d42c0e92a">&#9670;&#160;</a></span>composed_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::composed_of </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a module task for the target object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>target object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>a custom object that defines the method <code>T::graph()</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The example below demonstrates a taskflow composition using the <code>composed_of</code> method.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Taskflow.html">tf::Taskflow</a> t1, t2;</div>
<div class="line">t1.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;t1&quot;</span>; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// t2 is partially composed of t1</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> comp = t2.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#ac6f22228d4c2ea2e643c4b0d42c0e92a">composed_of</a>(t1);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> init = t2.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;t2&quot;</span>; });</div>
<div class="line">init.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(comp);</div>
<div class="ttc" id="abasic_ostream_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a></div></div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html_a60d7a666cab71ecfa3010b2efb0d6b57"><div class="ttname"><a href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">tf::FlowBuilder::emplace</a></div><div class="ttdeci">Task emplace(C &amp;&amp;callable)</div><div class="ttdoc">creates a static task</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:742</div></div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html_ac6f22228d4c2ea2e643c4b0d42c0e92a"><div class="ttname"><a href="classtf_1_1FlowBuilder.html#ac6f22228d4c2ea2e643c4b0d42c0e92a">tf::FlowBuilder::composed_of</a></div><div class="ttdeci">Task composed_of(T &amp;object)</div><div class="ttdoc">creates a module task for the target object</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:812</div></div>
<div class="ttc" id="aclasstf_1_1Task_html"><div class="ttname"><a href="classtf_1_1Task.html">tf::Task</a></div><div class="ttdoc">class to create a task handle over a node in a taskflow graph</div><div class="ttdef"><b>Definition</b> task.hpp:187</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_a8c78c453295a553c1c016e4062da8588"><div class="ttname"><a href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">tf::Task::precede</a></div><div class="ttdeci">Task &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> task.hpp:420</div></div>
<div class="ttc" id="aclasstf_1_1Taskflow_html"><div class="ttname"><a href="classtf_1_1Taskflow.html">tf::Taskflow</a></div><div class="ttdoc">class to create a taskflow object</div><div class="ttdef"><b>Definition</b> core/taskflow.hpp:73</div></div>
</div><!-- fragment --><p>The taskflow object <code>t2</code> is composed of another taskflow object <code>t1</code>, preceded by another static task <code>init</code>. When taskflow <code>t2</code> is submitted to an executor, <code>init</code> will run first and then <code>comp</code> which spwans its definition in taskflow <code>t1</code>.</p>
<p>The target <code>object</code> being composed must define the method <code>T::graph()</code> that returns a reference to a graph object of type <a class="el" href="classtf_1_1Graph.html" title="class to create a graph object">tf::Graph</a> such that it can interact with the executor. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// custom struct</span></div>
<div class="line"><span class="keyword">struct </span>MyObj {</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Graph.html">tf::Graph</a> graph;</div>
<div class="line">  MyObj() {</div>
<div class="line">    <a class="code hl_class" href="classtf_1_1FlowBuilder.html">tf::FlowBuilder</a> builder(graph);</div>
<div class="line">    <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> task = builder.emplace([](){</div>
<div class="line">      <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;a task\n&quot;</span>;  <span class="comment">// static task</span></div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">  Graph&amp; graph() { <span class="keywordflow">return</span> graph; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyObj obj;</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> comp = taskflow.<a class="code hl_function" href="classtf_1_1Task.html#ab38be520fe700cb4ca1f312308a95585">composed_of</a>(obj);</div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html"><div class="ttname"><a href="classtf_1_1FlowBuilder.html">tf::FlowBuilder</a></div><div class="ttdoc">class to build a task dependency graph</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:21</div></div>
<div class="ttc" id="aclasstf_1_1Graph_html"><div class="ttname"><a href="classtf_1_1Graph.html">tf::Graph</a></div><div class="ttdoc">class to create a graph object</div><div class="ttdef"><b>Definition</b> graph.hpp:56</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_ab38be520fe700cb4ca1f312308a95585"><div class="ttname"><a href="classtf_1_1Task.html#ab38be520fe700cb4ca1f312308a95585">tf::Task::composed_of</a></div><div class="ttdeci">Task &amp; composed_of(T &amp;object)</div><div class="ttdoc">creates a module task from a taskflow</div><div class="ttdef"><b>Definition</b> task.hpp:436</div></div>
</div><!-- fragment --><p>Please refer to <a class="el" href="ComposableTasking.html">Composable Tasking</a> for details. </p>

</div>
</div>
<a id="a1f6118326ad434f6c839007a1a79fe1b" name="a1f6118326ad434f6c839007a1a79fe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6118326ad434f6c839007a1a79fe1b">&#9670;&#160;</a></span>emplace() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... C, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;(sizeof...(C)&gt;1), void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;...&#160;</td>
          <td class="paramname"><em>callables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates multiple tasks from a list of callable objects </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable types</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callables</td><td>one or multiple callable objects constructible from each task category</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The method returns a tuple of tasks each corresponding to the given callable target. You can use structured binding to get the return tasks one by one. The following example creates four static tasks and assign them to <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> using structured binding.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [A, B, C, D] = taskflow.emplace(</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;A&quot;</span>; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;B&quot;</span>; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;C&quot;</span>; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;D&quot;</span>; }</div>
<div class="line">);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a60d7a666cab71ecfa3010b2efb0d6b57" name="a60d7a666cab71ecfa3010b2efb0d6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57">&#9670;&#160;</a></span>emplace() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf">is_syclflow_task_v</a>&lt; C &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a static task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from std::function&lt;void()&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>callable to construct a static task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates a static task.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> static_task = taskflow.emplace([](){});</div>
</div><!-- fragment --><p>Please refer to <a class="el" href="StaticTasking.html">Static Tasking</a> for details. </p>

</div>
</div>
<a id="a60d7a666cab71ecfa3010b2efb0d6b57" name="a60d7a666cab71ecfa3010b2efb0d6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57">&#9670;&#160;</a></span>emplace() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a1eea7593f25ab348cfb656dbdf4e5b05">is_dynamic_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a dynamic task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from std::function&lt;void(tf::Subflow&amp;)&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>callable to construct a dynamic task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates a dynamic task (<a class="el" href="classtf_1_1Subflow.html" title="class to construct a subflow graph from the execution of a dynamic task">tf::Subflow</a>) that spawns two static tasks.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> dynamic_task = taskflow.emplace([](<a class="code hl_class" href="classtf_1_1Subflow.html">tf::Subflow</a>&amp; sf){</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> static_task1 = sf.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](){});</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> static_task2 = sf.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](){});</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1Subflow_html"><div class="ttname"><a href="classtf_1_1Subflow.html">tf::Subflow</a></div><div class="ttdoc">class to construct a subflow graph from the execution of a dynamic task</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:889</div></div>
</div><!-- fragment --><p>Please refer to <a class="el" href="DynamicTasking.html">Dynamic Tasking</a> for details. </p>

</div>
</div>
<a id="a60d7a666cab71ecfa3010b2efb0d6b57" name="a60d7a666cab71ecfa3010b2efb0d6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57">&#9670;&#160;</a></span>emplace() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df">is_condition_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a condition task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from std::function&lt;int()&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>callable to construct a condition task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates an if-else block using one condition task and three static tasks.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Taskflow.html">tf::Taskflow</a> taskflow;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [init, cond, yes, no] = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>(</div>
<div class="line">  [] () { },</div>
<div class="line">  [] () { <span class="keywordflow">return</span> 0; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;yes\n&quot;</span>; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;no\n&quot;</span>; }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// executes yes if cond returns 0, or no if cond returns 1</span></div>
<div class="line">cond.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(yes, no);</div>
<div class="line">cond.<a class="code hl_function" href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">succeed</a>(init);</div>
<div class="ttc" id="aclasstf_1_1Task_html_a331b1b726555072e7c7d10941257f664"><div class="ttname"><a href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">tf::Task::succeed</a></div><div class="ttdeci">Task &amp; succeed(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from other tasks to this</div><div class="ttdef"><b>Definition</b> task.hpp:428</div></div>
</div><!-- fragment --><p>Please refer to <a class="el" href="ConditionalTasking.html">Conditional Tasking</a> for details. </p>

</div>
</div>
<a id="a60d7a666cab71ecfa3010b2efb0d6b57" name="a60d7a666cab71ecfa3010b2efb0d6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57">&#9670;&#160;</a></span>emplace() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a78c40dc8776735b0f2c27cd446481aff">is_multi_condition_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a multi-condition task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/function.html">std::function</a>&lt;tf::SmallVector&lt;int&gt;()&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>callable to construct a multi-condition task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates a multi-condition task that selectively jumps to two successor tasks.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Taskflow.html">tf::Taskflow</a> taskflow;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [init, cond, branch1, branch2, branch3] = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>(</div>
<div class="line">  [] () { },</div>
<div class="line">  [] () { <span class="keywordflow">return</span> <a class="code hl_class" href="classtf_1_1SmallVector.html">tf::SmallVector</a>{0, 2}; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;branch1\n&quot;</span>; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;branch2\n&quot;</span>; },</div>
<div class="line">  [] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;branch3\n&quot;</span>; }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// executes branch1 and branch3 when cond returns 0 and 2</span></div>
<div class="line">cond.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(branch1, branch2, branch3);</div>
<div class="line">cond.<a class="code hl_function" href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">succeed</a>(init);</div>
<div class="ttc" id="aclasstf_1_1SmallVector_html"><div class="ttname"><a href="classtf_1_1SmallVector.html">tf::SmallVector</a></div><div class="ttdoc">class to define a vector optimized for small array</div><div class="ttdef"><b>Definition</b> small_vector.hpp:918</div></div>
</div><!-- fragment --><p>Please refer to <a class="el" href="ConditionalTasking.html">Conditional Tasking</a> for details. </p>

</div>
</div>
<a id="a60d7a666cab71ecfa3010b2efb0d6b57" name="a60d7a666cab71ecfa3010b2efb0d6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57">&#9670;&#160;</a></span>emplace() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0">is_cudaflow_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a cudaFlow task on the caller's GPU device context </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::function&lt;void(tf::cudaFlow&amp;)&gt;</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>This method is equivalent to calling tf::FlowBuilder::emplace_on(callable, d) where <code>d</code> is the caller's device context. The following example creates a cudaFlow of two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p>
<div class="fragment"><div class="line">taskflow.emplace([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line">  <span class="comment">// create two kernel tasks</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task1 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(grid1, block1, shm1, kernel1, args1);</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task2 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(grid2, block2, shm2, kernel2, args2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// kernel1 runs before kernel2</span></div>
<div class="line">  task1.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(task2);</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html"><div class="ttname"><a href="classtf_1_1cudaFlow.html">tf::cudaFlow</a></div><div class="ttdoc">class to create a cudaFlow task dependency graph</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:56</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_aa6e734462c8b8d922f44e621f94b104c"><div class="ttname"><a href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">tf::cudaFlow::kernel</a></div><div class="ttdeci">cudaTask kernel(dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</div><div class="ttdoc">creates a kernel task</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1272</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html"><div class="ttname"><a href="classtf_1_1cudaTask.html">tf::cudaTask</a></div><div class="ttdoc">class to create a task handle over an internal node of a cudaFlow graph</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:65</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_abdd68287ec4dff4216af34d1db44d1b4"><div class="ttname"><a href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">tf::cudaTask::precede</a></div><div class="ttdeci">cudaTask &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:182</div></div>
</div><!-- fragment --><p>Please refer to <a class="el" href="GPUTaskingcudaFlow.html">GPU Tasking (cudaFlow)</a> and <a class="el" href="GPUTaskingcudaFlowCapturer.html">GPU Tasking (cudaFlowCapturer)</a> for details. </p>

</div>
</div>
<a id="a60d7a666cab71ecfa3010b2efb0d6b57" name="a60d7a666cab71ecfa3010b2efb0d6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57">&#9670;&#160;</a></span>emplace() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf">is_syclflow_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a syclFlow task on the default queue </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::function&lt;void(tf::syclFlow&amp;)&gt;</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>a callable that takes a referenced <a class="el" href="classtf_1_1syclFlow.html" title="class for building a SYCL task dependency graph">tf::syclFlow</a> object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates a syclFlow on the default queue to submit two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p>
<div class="fragment"><div class="line">taskflow.emplace([&amp;](<a class="code hl_class" href="classtf_1_1syclFlow.html">tf::syclFlow</a>&amp; cf){</div>
<div class="line">  <span class="comment">// create two single-thread kernel tasks</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1syclTask.html">tf::syclTask</a> task1 = cf.<a class="code hl_function" href="classtf_1_1syclFlow.html#a05ff6f331b6cf48e21ae7f0d6aea9094">single_task</a>([](){});</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1syclTask.html">tf::syclTask</a> task2 = cf.<a class="code hl_function" href="classtf_1_1syclFlow.html#a05ff6f331b6cf48e21ae7f0d6aea9094">single_task</a>([](){});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// kernel1 runs before kernel2</span></div>
<div class="line">  task1.<a class="code hl_function" href="classtf_1_1syclTask.html#a92d0dd0929b9ac4e46baf4d546497389">precede</a>(task2);</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1syclFlow_html"><div class="ttname"><a href="classtf_1_1syclFlow.html">tf::syclFlow</a></div><div class="ttdoc">class for building a SYCL task dependency graph</div><div class="ttdef"><b>Definition</b> syclflow.hpp:23</div></div>
<div class="ttc" id="aclasstf_1_1syclFlow_html_a05ff6f331b6cf48e21ae7f0d6aea9094"><div class="ttname"><a href="classtf_1_1syclFlow.html#a05ff6f331b6cf48e21ae7f0d6aea9094">tf::syclFlow::single_task</a></div><div class="ttdeci">syclTask single_task(F &amp;&amp;func)</div><div class="ttdoc">invokes a SYCL kernel function using only one thread</div><div class="ttdef"><b>Definition</b> syclflow.hpp:492</div></div>
<div class="ttc" id="aclasstf_1_1syclTask_html"><div class="ttname"><a href="classtf_1_1syclTask.html">tf::syclTask</a></div><div class="ttdoc">handle to a node of the internal CUDA graph</div><div class="ttdef"><b>Definition</b> sycl_task.hpp:21</div></div>
<div class="ttc" id="aclasstf_1_1syclTask_html_a92d0dd0929b9ac4e46baf4d546497389"><div class="ttname"><a href="classtf_1_1syclTask.html#a92d0dd0929b9ac4e46baf4d546497389">tf::syclTask::precede</a></div><div class="ttdeci">syclTask &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> sycl_task.hpp:131</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a60d7a666cab71ecfa3010b2efb0d6b57" name="a60d7a666cab71ecfa3010b2efb0d6b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57">&#9670;&#160;</a></span>emplace() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#af3d94f0be0f7b49e195c4e92737b1f85">is_runtime_task_v</a>&lt; C &gt;, void &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a runtime task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from std::function&lt;void(tf::Runtime&amp;)&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>callable to construct a runtime task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates a runtime task that enables in-task control over the running executor.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> runtime_task = taskflow.emplace([](<a class="code hl_class" href="classtf_1_1Runtime.html">tf::Runtime</a>&amp; rt){</div>
<div class="line">  <span class="keyword">auto</span>&amp; executor = rt.<a class="code hl_function" href="classtf_1_1Runtime.html#a4ee48a82df1f9758a999d18e6015cec4">executor</a>();</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; executor.num_workers() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1Runtime_html"><div class="ttname"><a href="classtf_1_1Runtime.html">tf::Runtime</a></div><div class="ttdoc">class to create a runtime object used by a runtime task</div><div class="ttdef"><b>Definition</b> graph.hpp:150</div></div>
<div class="ttc" id="aclasstf_1_1Runtime_html_a4ee48a82df1f9758a999d18e6015cec4"><div class="ttname"><a href="classtf_1_1Runtime.html#a4ee48a82df1f9758a999d18e6015cec4">tf::Runtime::executor</a></div><div class="ttdeci">Executor &amp; executor()</div><div class="ttdoc">obtains the running executor</div><div class="ttdef"><b>Definition</b> graph.hpp:233</div></div>
</div><!-- fragment --><p>Please refer to <a class="el" href="RuntimeTasking.html">Runtime Tasking</a> for details. </p>

</div>
</div>
<a id="afdf47fd1a358fb64f8c1b89e2a393169" name="afdf47fd1a358fb64f8c1b89e2a393169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf47fd1a358fb64f8c1b89e2a393169">&#9670;&#160;</a></span>emplace_on() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename D , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0">is_cudaflow_task_v</a>&lt; C &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace_on </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D &amp;&amp;&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a cudaFlow task on the given device </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::function&lt;void(tf::cudaFlow&amp;)&gt;</a> </td></tr>
    <tr><td class="paramname">D</td><td>device type, either <code>int</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::ref&lt;int&gt;</a></code> (stateful)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates a cudaFlow of two kernel tasks, <code>task1</code> and <code>task2</code> on GPU <code>2</code>, where <code>task1</code> runs before <code>task2</code> </p>
<div class="fragment"><div class="line">taskflow.emplace_on([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line">  <span class="comment">// create two kernel tasks</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task1 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(grid1, block1, shm1, kernel1, args1);</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task2 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(grid2, block2, shm2, kernel2, args2);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// kernel1 runs before kernel2</span></div>
<div class="line">  task1.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(task2);</div>
<div class="line">}, 2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af7c878fa6f0c4539ab88c0a85e6052d8" name="af7c878fa6f0c4539ab88c0a85e6052d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c878fa6f0c4539ab88c0a85e6052d8">&#9670;&#160;</a></span>emplace_on() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename Q , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="el" href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf">is_syclflow_task_v</a>&lt; C &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::emplace_on </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q &amp;&amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a syclFlow task on the given queue </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible from <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::function&lt;void(tf::syclFlow&amp;)&gt;</a> </td></tr>
    <tr><td class="paramname">Q</td><td>queue type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>a callable that takes a referenced <a class="el" href="classtf_1_1syclFlow.html" title="class for building a SYCL task dependency graph">tf::syclFlow</a> object </td></tr>
    <tr><td class="paramname">queue</td><td>a queue of type sycl::queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The following example creates a syclFlow on the given queue to submit two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p>
<div class="fragment"><div class="line">taskflow.emplace_on([&amp;](<a class="code hl_class" href="classtf_1_1syclFlow.html">tf::syclFlow</a>&amp; cf){</div>
<div class="line">  <span class="comment">// create two single-thread kernel tasks</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1syclTask.html">tf::syclTask</a> task1 = cf.<a class="code hl_function" href="classtf_1_1syclFlow.html#a05ff6f331b6cf48e21ae7f0d6aea9094">single_task</a>([](){});</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1syclTask.html">tf::syclTask</a> task2 = cf.<a class="code hl_function" href="classtf_1_1syclFlow.html#a05ff6f331b6cf48e21ae7f0d6aea9094">single_task</a>([](){});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// kernel1 runs before kernel2</span></div>
<div class="line">  task1.<a class="code hl_function" href="classtf_1_1syclTask.html#a92d0dd0929b9ac4e46baf4d546497389">precede</a>(task2);</div>
<div class="line">}, queue);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5627f7962099ac7c4986993cffa7b909" name="a5627f7962099ac7c4986993cffa7b909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5627f7962099ac7c4986993cffa7b909">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::FlowBuilder::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Task.html">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes a task from a taskflow </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>task to remove</td></tr>
  </table>
  </dd>
</dl>
<p>Removes a task and its input and output dependencies from the graph associated with the flow builder. If the task does not belong to the graph, nothing will happen.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> A = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;A&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> B = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;B&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> C = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;C&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> D = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;D&quot;</span>; });</div>
<div class="line">A.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(B, C, D);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// erase A from the taskflow and its dependencies to B, C, and D</span></div>
<div class="line">taskflow.erase(A);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab405d7b10040530d8b04c11767b4960d" name="ab405d7b10040530d8b04c11767b4960d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab405d7b10040530d8b04c11767b4960d">&#9670;&#160;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename E , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::for_each </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a STL-styled parallel-for task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>beginning iterator type </td></tr>
    <tr><td class="paramname">E</td><td>ending iterator type </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive) </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to apply to the dereferenced iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The task spawns a subflow that applies the callable object to each object obtained by dereferencing every iterator in the range <code>[first, last)</code>. This method is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> itr=first; itr!=last; itr++) {</div>
<div class="line">  callable(*itr);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Arguments templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type.</p>
<p>Please refer to <a class="el" href="ParallelIterations.html">Parallel Iterations</a> for details. </p>

</div>
</div>
<a id="a38ffe176bc3ae1827b9964322e3769d4" name="a38ffe176bc3ae1827b9964322e3769d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ffe176bc3ae1827b9964322e3769d4">&#9670;&#160;</a></span>for_each_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename E , typename S , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::for_each_index </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a parallel-transform task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>beginning index type (must be integral) </td></tr>
    <tr><td class="paramname">E</td><td>ending index type (must be integral) </td></tr>
    <tr><td class="paramname">S</td><td>step type (must be integral) </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>index of the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>index of the end (exclusive) </td></tr>
    <tr><td class="paramname">step</td><td>step size </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to apply to each valid index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The task spawns a subflow that applies the callable object to each index in the range <code>[first, last)</code> with the step size. This method is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="comment">// case 1: step size is positive</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i=first; i&lt;last; i+=step) {</div>
<div class="line">  callable(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// case 2: step size is negative</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i=first, i&gt;last; i+=step) {</div>
<div class="line">  callable(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Arguments are templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>. The callable needs to take a single argument of the integral index type.</p>
<p>Please refer to <a class="el" href="ParallelIterations.html">Parallel Iterations</a> for details. </p>

</div>
</div>
<a id="a4ec89b554d15ad5fb96f4fdb10dbbb16" name="a4ec89b554d15ad5fb96f4fdb10dbbb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec89b554d15ad5fb96f4fdb10dbbb16">&#9670;&#160;</a></span>linearize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::FlowBuilder::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; <a class="el" href="classtf_1_1Task.html">Task</a> &gt;&#160;</td>
          <td class="paramname"><em>tasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds adjacent dependency links to a linear list of tasks </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>an initializer list of tasks</td></tr>
  </table>
  </dd>
</dl>
<p>This member function creates linear dependencies over a list of tasks.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> A = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;A&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> B = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;B&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> C = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;C&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> D = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;D&quot;</span>; });</div>
<div class="line">taskflow.linearize({A, B, C, D});  <span class="comment">// A-&gt;B-&gt;C-&gt;D</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a90f3d9b9d6fcf4df8e7d7878dfdd130d" name="a90f3d9b9d6fcf4df8e7d7878dfdd130d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f3d9b9d6fcf4df8e7d7878dfdd130d">&#9670;&#160;</a></span>linearize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::FlowBuilder::linearize </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classtf_1_1Task.html">Task</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds adjacent dependency links to a linear list of tasks </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>a vector of tasks</td></tr>
  </table>
  </dd>
</dl>
<p>This member function creates linear dependencies over a vector of tasks.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> A = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;A&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> B = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;B&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> C = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;C&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> D = taskflow.emplace([](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;D&quot;</span>; });</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;tf::Task&gt;</a> tasks {A, B, C, D}</div>
<div class="line">taskflow.linearize(tasks);  <span class="comment">// A-&gt;B-&gt;C-&gt;D</span></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acab0b4ac82260f47fdb36a3244ee3aaf" name="acab0b4ac82260f47fdb36a3244ee3aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab0b4ac82260f47fdb36a3244ee3aaf">&#9670;&#160;</a></span>placeholder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::placeholder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a placeholder task </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>A placeholder task maps to a node in the taskflow graph, but it does not have any callable work assigned yet. A placeholder task is different from an empty task handle that does not point to any node in a graph.</p>
<div class="fragment"><div class="line"><span class="comment">// create a placeholder task with no callable target assigned</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> <a class="code hl_function" href="classtf_1_1FlowBuilder.html#acab0b4ac82260f47fdb36a3244ee3aaf">placeholder</a> = taskflow.placeholder();</div>
<div class="line">assert(<a class="code hl_function" href="classtf_1_1FlowBuilder.html#acab0b4ac82260f47fdb36a3244ee3aaf">placeholder</a>.<a class="code hl_function" href="classtf_1_1Task.html#a8149edcf9ec2bfac18dd171f7a55ce06">empty</a>() == <span class="keyword">false</span> &amp;&amp; <a class="code hl_function" href="classtf_1_1FlowBuilder.html#acab0b4ac82260f47fdb36a3244ee3aaf">placeholder</a>.<a class="code hl_function" href="classtf_1_1Task.html#afc4ecb89dd4e4645b3ec3fb7c1bb0ec5">has_work</a>() == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create an empty task handle</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> task;</div>
<div class="line">assert(task.<a class="code hl_function" href="classtf_1_1Task.html#a8149edcf9ec2bfac18dd171f7a55ce06">empty</a>() == <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// assign the task handle to the placeholder task</span></div>
<div class="line">task = <a class="code hl_function" href="classtf_1_1FlowBuilder.html#acab0b4ac82260f47fdb36a3244ee3aaf">placeholder</a>;</div>
<div class="line">assert(task.<a class="code hl_function" href="classtf_1_1Task.html#a8149edcf9ec2bfac18dd171f7a55ce06">empty</a>() == <span class="keyword">false</span> &amp;&amp; task.<a class="code hl_function" href="classtf_1_1Task.html#afc4ecb89dd4e4645b3ec3fb7c1bb0ec5">has_work</a>() == <span class="keyword">false</span>);</div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html_acab0b4ac82260f47fdb36a3244ee3aaf"><div class="ttname"><a href="classtf_1_1FlowBuilder.html#acab0b4ac82260f47fdb36a3244ee3aaf">tf::FlowBuilder::placeholder</a></div><div class="ttdeci">Task placeholder()</div><div class="ttdoc">creates a placeholder task</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:820</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_a8149edcf9ec2bfac18dd171f7a55ce06"><div class="ttname"><a href="classtf_1_1Task.html#a8149edcf9ec2bfac18dd171f7a55ce06">tf::Task::empty</a></div><div class="ttdeci">bool empty() const</div><div class="ttdoc">queries if the task handle points to a task node</div><div class="ttdef"><b>Definition</b> task.hpp:524</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_afc4ecb89dd4e4645b3ec3fb7c1bb0ec5"><div class="ttname"><a href="classtf_1_1Task.html#afc4ecb89dd4e4645b3ec3fb7c1bb0ec5">tf::Task::has_work</a></div><div class="ttdeci">bool has_work() const</div><div class="ttdoc">queries if the task has a work assigned</div><div class="ttdef"><b>Definition</b> task.hpp:529</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa9494fe7b862fc832884ce318e8a37f5" name="aa9494fe7b862fc832884ce318e8a37f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9494fe7b862fc832884ce318e8a37f5">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename E , typename T , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::reduce </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>bop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a STL-styled parallel-reduce task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>beginning iterator type </td></tr>
    <tr><td class="paramname">E</td><td>ending iterator type </td></tr>
    <tr><td class="paramname">T</td><td>result type </td></tr>
    <tr><td class="paramname">O</td><td>binary reducer type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive) </td></tr>
    <tr><td class="paramname">init</td><td>initial value of the reduction and the storage for the reduced result </td></tr>
    <tr><td class="paramname">bop</td><td>binary operator that will be applied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. This method is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> itr=first; itr!=last; itr++) {</div>
<div class="line">  init = bop(init, *itr);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Arguments are templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>.</p>
<p>Please refer to <a class="el" href="ParallelReduction.html">Parallel Reduction</a> for details. </p>

</div>
</div>
<a id="a7d844e9856c7c65b26ccdb83ffdab1d6" name="a7d844e9856c7c65b26ccdb83ffdab1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d844e9856c7c65b26ccdb83ffdab1d6">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::sort </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a dynamic task to perform STL-styled parallel sort using the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::less&lt;T&gt;</a></code> comparator, where <code>T</code> is the element type </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>beginning iterator type (random-accessible) </td></tr>
    <tr><td class="paramname">E</td><td>ending iterator type (random-accessible)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive)</td></tr>
  </table>
  </dd>
</dl>
<p>The task spawns a subflow to parallelly sort elements in the range <code>[first, last)</code> using the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::less&lt;T&gt;</a></code> comparator, where <code>T</code> is the dereferenced iterator type.</p>
<p>Arguments are templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>.</p>
<p>Please refer to <a class="el" href="ParallelSort.html">Parallel Sort</a> for details. </p>

</div>
</div>
<a id="a35e180eb63de6c9f28e43185e837a4fa" name="a35e180eb63de6c9f28e43185e837a4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e180eb63de6c9f28e43185e837a4fa">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename E , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::sort </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a dynamic task to perform STL-styled parallel sort </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>beginning iterator type (random-accessible) </td></tr>
    <tr><td class="paramname">E</td><td>ending iterator type (random-accessible) </td></tr>
    <tr><td class="paramname">C</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive) </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison function object</td></tr>
  </table>
  </dd>
</dl>
<p>The task spawns a subflow to parallelly sort elements in the range <code>[first, last)</code>.</p>
<p>Arguments are templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>.</p>
<p>Please refer to <a class="el" href="ParallelSort.html">Parallel Sort</a> for details. </p>

</div>
</div>
<a id="abd813bd7afcbd8e6f56dc67883917d1a" name="abd813bd7afcbd8e6f56dc67883917d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd813bd7afcbd8e6f56dc67883917d1a">&#9670;&#160;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename E , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::transform </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a parallel-transform task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>beginning input iterator type </td></tr>
    <tr><td class="paramname">E</td><td>ending input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>iterator to the beginning of the first range </td></tr>
    <tr><td class="paramname">last1</td><td>iterator to the end of the first range </td></tr>
    <tr><td class="paramname">d_first</td><td>iterator to the beginning of the output range </td></tr>
    <tr><td class="paramname">c</td><td>an unary callable to apply to dereferenced input elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The task spawns a subflow that applies the callable object to an input range and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first1 != last1) {</div>
<div class="line">  *d_first++ = c(*first1++);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Arguments are templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type. </p>

</div>
</div>
<a id="aa0b3271b34317710a1e32053a9abc3cf" name="aa0b3271b34317710a1e32053a9abc3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b3271b34317710a1e32053a9abc3cf">&#9670;&#160;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B1 , typename E1 , typename B2 , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::transform </td>
          <td>(</td>
          <td class="paramtype">B1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a parallel-transform task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B1</td><td>beginning input iterator type for the first input range </td></tr>
    <tr><td class="paramname">E1</td><td>ending input iterator type for the first input range </td></tr>
    <tr><td class="paramname">B2</td><td>beginning input iterator type for the first second range </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>iterator to the beginning of the first input range </td></tr>
    <tr><td class="paramname">last1</td><td>iterator to the end of the first input range </td></tr>
    <tr><td class="paramname">first2</td><td>iterator to the beginning of the second input range </td></tr>
    <tr><td class="paramname">d_first</td><td>iterator to the beginning of the output range </td></tr>
    <tr><td class="paramname">c</td><td>a binary operator to apply to dereferenced input elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The task spawns a subflow that applies the callable object to two input ranges and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first1 != last1) {</div>
<div class="line">  *d_first++ = c(*first1++, *first2++);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Arguments are templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>. The callable needs to take two arguments of dereferenced elements from the two input ranges. </p>

</div>
</div>
<a id="a024a1e5b4f138b6caebb427411fb0a2d" name="a024a1e5b4f138b6caebb427411fb0a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024a1e5b4f138b6caebb427411fb0a2d">&#9670;&#160;</a></span>transform_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename E , typename T , typename BOP , typename UOP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Task.html">Task</a> tf::FlowBuilder::transform_reduce </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOP&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UOP&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a STL-styled parallel transform-reduce task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>beginning iterator type </td></tr>
    <tr><td class="paramname">E</td><td>ending iterator type </td></tr>
    <tr><td class="paramname">T</td><td>result type </td></tr>
    <tr><td class="paramname">BOP</td><td>binary reducer type </td></tr>
    <tr><td class="paramname">UOP</td><td>unary transformion type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning (inclusive) </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end (exclusive) </td></tr>
    <tr><td class="paramname">init</td><td>initial value of the reduction and the storage for the reduced result </td></tr>
    <tr><td class="paramname">bop</td><td>binary operator that will be applied in unspecified order to the results of <code>uop</code> </td></tr>
    <tr><td class="paramname">uop</td><td>unary operator that will be applied to transform each element in the range to the result type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a> handle</dd></dl>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. This method is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> itr=first; itr!=last; itr++) {</div>
<div class="line">  init = bop(init, uop(*itr));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Arguments are templated to enable stateful range using <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html">std::reference_wrapper</a>.</p>
<p>Please refer to <a class="el" href="ParallelReduction.html">Parallel Reduction</a> for details. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="flow__builder_8hpp_source.html">flow_builder.hpp</a></li>
<li><a class="el" href="cudaflow_8hpp_source.html">cudaflow.hpp</a></li>
<li><a class="el" href="syclflow_8hpp_source.html">syclflow.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetf.html">tf</a></li><li class="navelem"><a class="el" href="classtf_1_1FlowBuilder.html">FlowBuilder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
