<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Taskflow Handbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/x-icon" href="favicon.ico" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="taskflow_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://taskflow.github.io/">Taskflow</a>
   &#160;<span id="projectnumber">3.2.0-Master-Branch</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('GPUTaskingcudaFlowCapturer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GPU Tasking (cudaFlowCapturer)</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#GPUTaskingcudaFlowCapturerIncludeTheHeader">Include the Header</a></li>
<li class="level1"><a href="#Capture_a_cudaFlow">Capture a cudaFlow</a></li>
<li class="level1"><a href="#CommonCaptureMethods">Common Capture Methods</a></li>
<li class="level1"><a href="#CreateACapturerOnASpecificGPU">Create a Capturer on a Specific GPU</a></li>
<li class="level1"><a href="#CreateACapturerWithinAcudaFlow">Create a Capturer within a cudaFlow</a></li>
<li class="level1"><a href="#OffloadAcudaFlowCapturer">Offload a cudaFlow Capturer</a></li>
<li class="level1"><a href="#UpdateAcudaFlowCapturer">Update a cudaFlow Capturer</a></li>
<li class="level1"><a href="#UsecudaFlowCapturerInAStandaloneEnvironment">Use cudaFlow Capturer in a Standalone Environment</a></li>
</ul>
</div>
<div class="textblock"><p>You can create a cudaFlow through <em>stream capture</em>, which allows you to implicitly capture a CUDA graph using stream-based interface. Compared to explicit CUDA Graph construction (<a class="el" href="classtf_1_1cudaFlow.html" title="class to create a cudaFlow task dependency graph">tf::cudaFlow</a>), implicit CUDA Graph capturing (<a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a>) is more flexible in building GPU task graphs.</p>
<h1><a class="anchor" id="GPUTaskingcudaFlowCapturerIncludeTheHeader"></a>
Include the Header</h1>
<p>You need to include the header file, <code>taskflow/cuda/cudaflow.hpp</code>, for creating a <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> task.</p>
<h1><a class="anchor" id="Capture_a_cudaFlow"></a>
Capture a cudaFlow</h1>
<p>When your program has no access to direct kernel calls but invoke it through a stream-based interface (e.g., <a href="https://docs.nvidia.com/cuda/cublas/index.html">cuBLAS</a> and <a href="https://developer.nvidia.com/cudnn">cuDNN</a> library functions), you can use <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> to capture the hidden GPU operations into a CUDA graph. A cudaFlowCapturer is similar to a cudaFlow except it constructs a GPU task graph through <em>stream capture</em>. You use the method <a class="el" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41" title="captures a sequential CUDA operations from the given callable">tf::cudaFlowCapturer::on</a> to capture a sequence of <em>asynchronous</em> GPU operations through the given stream. The following example creates a CUDA graph that captures two kernel tasks, <code>task_1</code> (<code>my_kernel_1</code>) and <code>task_2</code> (<code>my_kernel_2</code>) , where <code>task_1</code> runs before <code>task_2</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cudaflow_8hpp.html">taskflow/cuda/cudaflow.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Executor.html">tf::Executor</a> executor;</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Taskflow.html">tf::Taskflow</a> taskflow;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> task = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; capturer){</div>
<div class="line">    <span class="comment">// capture my_kernel_1 through a stream managed by capturer</span></div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task_1 = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){ </div>
<div class="line">      my_kernel_1&lt;&lt;&lt;grid_1, block_1, shm_size_1, stream&gt;&gt;&gt;(my_parameters_1);</div>
<div class="line">    }).name(<span class="stringliteral">&quot;my_kernel_1&quot;</span>);</div>
<div class="line">  </div>
<div class="line">    <span class="comment">// capture my_kernel_2 through a stream managed by capturer</span></div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task_2 = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){ </div>
<div class="line">      my_kernel_2&lt;&lt;&lt;grid_2, block_2, shm_size_2, stream&gt;&gt;&gt;(my_parameters_2);</div>
<div class="line">    }).name(<span class="stringliteral">&quot;my_kernel_2&quot;</span>);</div>
<div class="line">  </div>
<div class="line">    <span class="comment">// my_kernel_1 runs before my_kernel_2</span></div>
<div class="line">    task_1.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(task_2);</div>
<div class="line">  }).name(<span class="stringliteral">&quot;capturer&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  executor.<a class="code hl_function" href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">run</a>(taskflow).wait();</div>
<div class="line"> </div>
<div class="line">  taskflow.<a class="code hl_function" href="classtf_1_1Taskflow.html#ac433018262e44b12c4cc9f0c4748d758">dump</a>(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="abasic_ostream_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a></div></div>
<div class="ttc" id="aclasstf_1_1Executor_html"><div class="ttname"><a href="classtf_1_1Executor.html">tf::Executor</a></div><div class="ttdoc">class to create an executor for running a taskflow graph</div><div class="ttdef"><b>Definition</b> executor.hpp:50</div></div>
<div class="ttc" id="aclasstf_1_1Executor_html_a519777f5783981d534e9e53b99712069"><div class="ttname"><a href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">tf::Executor::run</a></div><div class="ttdeci">tf::Future&lt; void &gt; run(Taskflow &amp;taskflow)</div><div class="ttdoc">runs a taskflow once</div><div class="ttdef"><b>Definition</b> executor.hpp:1573</div></div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html_a60d7a666cab71ecfa3010b2efb0d6b57"><div class="ttname"><a href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">tf::FlowBuilder::emplace</a></div><div class="ttdeci">Task emplace(C &amp;&amp;callable)</div><div class="ttdoc">creates a static task</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:742</div></div>
<div class="ttc" id="aclasstf_1_1Task_html"><div class="ttname"><a href="classtf_1_1Task.html">tf::Task</a></div><div class="ttdoc">class to create a task handle over a node in a taskflow graph</div><div class="ttdef"><b>Definition</b> task.hpp:187</div></div>
<div class="ttc" id="aclasstf_1_1Taskflow_html"><div class="ttname"><a href="classtf_1_1Taskflow.html">tf::Taskflow</a></div><div class="ttdoc">class to create a taskflow object</div><div class="ttdef"><b>Definition</b> core/taskflow.hpp:73</div></div>
<div class="ttc" id="aclasstf_1_1Taskflow_html_ac433018262e44b12c4cc9f0c4748d758"><div class="ttname"><a href="classtf_1_1Taskflow.html#ac433018262e44b12c4cc9f0c4748d758">tf::Taskflow::dump</a></div><div class="ttdeci">void dump(std::ostream &amp;ostream) const</div><div class="ttdoc">dumps the taskflow to a DOT format through a std::ostream target</div><div class="ttdef"><b>Definition</b> core/taskflow.hpp:363</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a></div><div class="ttdoc">class to create a cudaFlow graph using stream capture</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:57</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_ad0d937ae0d77239f148b66a77e35db41"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">tf::cudaFlowCapturer::on</a></div><div class="ttdeci">cudaTask on(C &amp;&amp;callable)</div><div class="ttdoc">captures a sequential CUDA operations from the given callable</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1105</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html"><div class="ttname"><a href="classtf_1_1cudaTask.html">tf::cudaTask</a></div><div class="ttdoc">class to create a task handle over an internal node of a cudaFlow graph</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:65</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_abdd68287ec4dff4216af34d1db44d1b4"><div class="ttname"><a href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">tf::cudaTask::precede</a></div><div class="ttdeci">cudaTask &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:182</div></div>
<div class="ttc" id="acudaflow_8hpp_html"><div class="ttname"><a href="cudaflow_8hpp.html">cudaflow.hpp</a></div><div class="ttdoc">cudaFlow include file</div></div>
</div><!-- fragment --><div class="dotgraph">
<img src="dot_cudaflow_capturer_1.png" alt="dot_cudaflow_capturer_1.png" border="0" usemap="#dot_cudaflow_capturer_1.map"/>
</div>
<dl class="section warning"><dt>Warning</dt><dd>Inside <a class="el" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41" title="captures a sequential CUDA operations from the given callable">tf::cudaFlowCapturer::on</a>, you should <em>NOT</em> modify the properties of the stream argument but only use it to capture <em>asynchronous</em> GPU operations (e.g., <code>kernel</code>, <code>cudaMemcpyAsync</code>).</dd></dl>
<h1><a class="anchor" id="CommonCaptureMethods"></a>
Common Capture Methods</h1>
<p>cudaFlowCapturer defines a set of methods for capturing common GPU operations, such as <a class="el" href="classtf_1_1cudaFlowCapturer.html#a6f06c7f6954d8d67ad89f0eddfe285e9" title="captures a kernel">tf::cudaFlowCapturer::kernel</a>, <a class="el" href="classtf_1_1cudaFlowCapturer.html#ae84d097cdae9e2e8ce108dea760483ed" title="copies data between host and device asynchronously through a stream">tf::cudaFlowCapturer::memcpy</a>, <a class="el" href="classtf_1_1cudaFlowCapturer.html#a0d38965b380f940bf6cfc6667a281052" title="initializes or sets GPU memory to the given value byte by byte">tf::cudaFlowCapturer::memset</a>, and so on. For example, the following code snippet uses these pre-defined methods to construct a GPU task graph of one host-to-device copy, kernel, and one device-to-host copy, in this order of their dependencies.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> task = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; capturer){</div>
<div class="line">  <span class="comment">// copy data from host_data to gpu_data</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> h2d = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ae84d097cdae9e2e8ce108dea760483ed">memcpy</a>(gpu_data, host_data, bytes).name(<span class="stringliteral">&quot;h2d&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// capture my_kernel to do computation on gpu_data</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> kernel = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){  </div>
<div class="line">    my_kernel&lt;&lt;&lt;grid, block, shm_size, stream&gt;&gt;&gt;(gpu_data, arg1, arg2, ...);</div>
<div class="line">  }).name(<span class="stringliteral">&quot;my_kernel&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// copy data from gpu_data to host_data</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> d2h = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ae84d097cdae9e2e8ce108dea760483ed">memcpy</a>(host_data, gpu_data, bytes).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;d2h&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  h2d.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(kernel);</div>
<div class="line">  kernel.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(d2h);</div>
<div class="line">}).name(<span class="stringliteral">&quot;capturer&quot;</span>);</div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_ae84d097cdae9e2e8ce108dea760483ed"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#ae84d097cdae9e2e8ce108dea760483ed">tf::cudaFlowCapturer::memcpy</a></div><div class="ttdeci">cudaTask memcpy(void *dst, const void *src, size_t count)</div><div class="ttdoc">copies data between host and device asynchronously through a stream</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1123</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_ab81b4f71a44af8d61758524f0c274962"><div class="ttname"><a href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">tf::cudaTask::name</a></div><div class="ttdeci">cudaTask &amp; name(const std::string &amp;name)</div><div class="ttdoc">assigns a name to the task</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:200</div></div>
</div><!-- fragment --><div class="dotgraph">
<img src="dot_cudaflow_capturer_2.png" alt="dot_cudaflow_capturer_2.png" border="0" usemap="#dot_cudaflow_capturer_2.map"/>
</div>
<h1><a class="anchor" id="CreateACapturerOnASpecificGPU"></a>
Create a Capturer on a Specific GPU</h1>
<p>You can capture a cudaFlow on a specific GPU by calling <a class="el" href="classtf_1_1FlowBuilder.html#afdf47fd1a358fb64f8c1b89e2a393169" title="creates a cudaFlow task on the given device">tf::Taskflow::emplace_on</a>. By default, a cudaFlow runs on the current GPU associated with the caller, which is typically 0. You can emplace a cudaFlowCapturer on a specific GPU. The following example creates a capturer on GPU 2. When the executor runs the callable, it switches to GPU 2 and scopes the callable under this GPU context.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> task = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#afdf47fd1a358fb64f8c1b89e2a393169">emplace_on</a>([](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; capturer){</div>
<div class="line">  <span class="comment">// here, capturer is under GPU device 2</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}, 2);</div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html_afdf47fd1a358fb64f8c1b89e2a393169"><div class="ttname"><a href="classtf_1_1FlowBuilder.html#afdf47fd1a358fb64f8c1b89e2a393169">tf::FlowBuilder::emplace_on</a></div><div class="ttdeci">Task emplace_on(C &amp;&amp;callable, D &amp;&amp;device)</div><div class="ttdoc">creates a cudaFlow task on the given device</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1666</div></div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>It is your responsibility to allocate the GPU memory in the same GPU context as the capturer.</dd></dl>
<h1><a class="anchor" id="CreateACapturerWithinAcudaFlow"></a>
Create a Capturer within a cudaFlow</h1>
<p>Within a parent cudaFlow, you can capture a cudaFlow to form a subflow that eventually becomes a <em>child</em> node in the underlying CUDA task graph. The following example defines a captured flow <code>task2</code> of two dependent tasks, <code>task2_1</code> and <code>task2_2</code>, and <code>task2</code> runs after <code>task1</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> task = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task1 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(grid, block, shm, my_kernel, args...)</div>
<div class="line">                         .<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;my_kernel&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// task2 forms a subflow in cf and becomes a child node in the underlying </span></div>
<div class="line">  <span class="comment">// CUDA graph</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task2 = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a89c389fff64a16e5dd8c60875d3b514d">capture</a>([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; capturer){</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// capture my_kernel1 using the given stream</span></div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task2_1 = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){  </div>
<div class="line">      my_kernel2&lt;&lt;&lt;grid1, block1, shm_size1, stream&gt;&gt;&gt;(args1...);</div>
<div class="line">    }).name(<span class="stringliteral">&quot;my_kernel1&quot;</span>);  </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// capture my_kernel2 using the given stream</span></div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task2_2 = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){  </div>
<div class="line">      my_kernel2&lt;&lt;&lt;grid2, block2, shm_size2, stream&gt;&gt;&gt;(args2...);</div>
<div class="line">    }).name(<span class="stringliteral">&quot;my_kernel2&quot;</span>);   </div>
<div class="line"> </div>
<div class="line">    task2_1.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(task2_2);</div>
<div class="line">  }).name(<span class="stringliteral">&quot;capturer&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  task1.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(task2);</div>
<div class="line">}).name(<span class="stringliteral">&quot;cudaFlow&quot;</span>);</div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html"><div class="ttname"><a href="classtf_1_1cudaFlow.html">tf::cudaFlow</a></div><div class="ttdoc">class to create a cudaFlow task dependency graph</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:56</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_a89c389fff64a16e5dd8c60875d3b514d"><div class="ttname"><a href="classtf_1_1cudaFlow.html#a89c389fff64a16e5dd8c60875d3b514d">tf::cudaFlow::capture</a></div><div class="ttdeci">cudaTask capture(C &amp;&amp;callable)</div><div class="ttdoc">constructs a subflow graph through tf::cudaFlowCapturer</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1582</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_aa6e734462c8b8d922f44e621f94b104c"><div class="ttname"><a href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">tf::cudaFlow::kernel</a></div><div class="ttdeci">cudaTask kernel(dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</div><div class="ttdoc">creates a kernel task</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1272</div></div>
</div><!-- fragment --><div class="dotgraph">
<img src="dot_cudaflow_capturer_3.png" alt="dot_cudaflow_capturer_3.png" border="0" usemap="#dot_cudaflow_capturer_3.map"/>
</div>
<h1><a class="anchor" id="OffloadAcudaFlowCapturer"></a>
Offload a cudaFlow Capturer</h1>
<p>By default, the executor offloads and executes the cudaFlow capturer once. When you offload a cudaFlow capturer, the Taskflow runtime transforms the user-described graph into an executable graph that is optimized for maximum stream concurrency. Depending on the optimization algorithm, the user-described graph may be different from the actual executable graph submitted to the CUDA runtime. Similar to <a class="el" href="classtf_1_1Executor.html" title="class to create an executor for running a taskflow graph">tf::Executor</a>, <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> provides several offload methods to run the GPU task graph:</p>
<div class="fragment"><div class="line">taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; cf) {</div>
<div class="line">  <span class="comment">// ... capture CUDA tasks</span></div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">offload</a>();      <span class="comment">// offload the cudaFlow capturer and run it once</span></div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a0bc6231cc6b1dbf5171b0bc421dc6577">offload_n</a>(10);  <span class="comment">// offload the cudaFlow capturer and run it 10 times</span></div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a8678573f19e01f441a6b4108e62781f3">offload_until</a>([repeat=5] () <span class="keyword">mutable</span> { <span class="keywordflow">return</span> repeat-- == 0; })  <span class="comment">// five times</span></div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_a0bc6231cc6b1dbf5171b0bc421dc6577"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#a0bc6231cc6b1dbf5171b0bc421dc6577">tf::cudaFlowCapturer::offload_n</a></div><div class="ttdeci">void offload_n(size_t n)</div><div class="ttdoc">offloads the captured cudaFlow and executes it by the given times</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1237</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_a5959002af1cf1a1ada3d86a073682232"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">tf::cudaFlowCapturer::offload</a></div><div class="ttdeci">void offload()</div><div class="ttdoc">offloads the captured cudaFlow and executes it once</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1242</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_a8678573f19e01f441a6b4108e62781f3"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#a8678573f19e01f441a6b4108e62781f3">tf::cudaFlowCapturer::offload_until</a></div><div class="ttdeci">void offload_until(P &amp;&amp;predicate)</div><div class="ttdoc">offloads the captured cudaFlow onto a GPU and repeatedly runs it until the predicate becomes true</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1173</div></div>
</div><!-- fragment --><p>After you offload a cudaFlow capturer, it is considered executed, and the executor will <em>not</em> run an offloaded cudaFlow after leaving the cudaFlow capturer task callable. On the other hand, if a cudaFlow capturer is not offloaded, the executor runs it once. For example, the following two versions represent the same execution logic.</p>
<div class="fragment"><div class="line"><span class="comment">// version 1: explicitly offload a cudaFlow capturer once</span></div>
<div class="line">taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; cf) {</div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ac944c7d20056e0633ef84f1a25b52296">single_task</a>([] __device__ (){});</div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">offload</a>();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// version 2 (same as version 1): executor offloads the cudaFlow capturer once</span></div>
<div class="line">taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; sf) {</div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ac944c7d20056e0633ef84f1a25b52296">single_task</a>([] __device__ (){});</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_ac944c7d20056e0633ef84f1a25b52296"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#ac944c7d20056e0633ef84f1a25b52296">tf::cudaFlowCapturer::single_task</a></div><div class="ttdeci">cudaTask single_task(C c)</div><div class="ttdoc">capturers a kernel to runs the given callable with only one thread</div><div class="ttdef"><b>Definition</b> for_each.hpp:259</div></div>
</div><!-- fragment --><h1><a class="anchor" id="UpdateAcudaFlowCapturer"></a>
Update a cudaFlow Capturer</h1>
<p>Between successive offloads (i.e., executions of a cudaFlow capturer), you can update the captured task with a different set of parameters. For example, you can update a kernel task to a memory task from an offloaded cudaFlow capturer.</p>
<div class="fragment"><div class="line">taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>(<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; cf) {</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> task = cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a6f06c7f6954d8d67ad89f0eddfe285e9">kernel</a>(grid1, block1, shm1, kernel1, kernel1_args);</div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">offload</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// update task to another kernel with different parameters</span></div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a6f06c7f6954d8d67ad89f0eddfe285e9">kernel</a>(task, grid2, block2, shm2, kernel2, kernel2_args);</div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">offload</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// update task to another task type is OK in a capturer</span></div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a0d38965b380f940bf6cfc6667a281052">memset</a>(task, target, 0, num_bytes);</div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">offload</a>();</div>
<div class="line">};</div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_a0d38965b380f940bf6cfc6667a281052"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#a0d38965b380f940bf6cfc6667a281052">tf::cudaFlowCapturer::memset</a></div><div class="ttdeci">cudaTask memset(void *ptr, int v, size_t n)</div><div class="ttdoc">initializes or sets GPU memory to the given value byte by byte</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1146</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_a6f06c7f6954d8d67ad89f0eddfe285e9"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#a6f06c7f6954d8d67ad89f0eddfe285e9">tf::cudaFlowCapturer::kernel</a></div><div class="ttdeci">cudaTask kernel(dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</div><div class="ttdoc">captures a kernel</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1156</div></div>
</div><!-- fragment --><p>When you offload a updated cudaFlow capturer, the runtime will try to update the underlying executable with the new captured graph first, or destroy the executable graph and replace it with a new one. Each method of task creation in <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> has an overload of updating the parameters of the task created from the same creation method.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="classtf_1_1cudaFlow.html" title="class to create a cudaFlow task dependency graph">tf::cudaFlow</a> that is restrictive about the use of update methods, it is valid to alter the topology and change the type of a captured task between successive execution of a cudaFlow capturer.</dd></dl>
<h1><a class="anchor" id="UsecudaFlowCapturerInAStandaloneEnvironment"></a>
Use cudaFlow Capturer in a Standalone Environment</h1>
<p>You can use <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> in a standalone environment without going through <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> and offloads it to a GPU from the caller thread. All the features we have discussed so far apply to the standalone use.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a> cf;  <span class="comment">// create a standalone cudaFlow capturer</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> h2d_x = cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ab70f12050e78b588f5c23d874aa4e538">copy</a>(dx, hx.data(), N).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;h2d_x&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> h2d_y = cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ab70f12050e78b588f5c23d874aa4e538">copy</a>(dy, hy.data(), N).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;h2d_y&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> d2h_x = cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ab70f12050e78b588f5c23d874aa4e538">copy</a>(hx.data(), dx, N).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;d2h_x&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> d2h_y = cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ab70f12050e78b588f5c23d874aa4e538">copy</a>(hy.data(), dy, N).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;d2h_y&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> saxpy = cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a6f06c7f6954d8d67ad89f0eddfe285e9">kernel</a>((N+255)/256, 256, 0, saxpy, N, 2.0f, dx, dy)</div>
<div class="line">                       .<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;saxpy&quot;</span>);</div>
<div class="line"> </div>
<div class="line">saxpy.<a class="code hl_function" href="classtf_1_1cudaTask.html#a4a9ca1a34bac47e4c9b04eb4fb2f7775">succeed</a>(h2d_x, h2d_y)   <span class="comment">// kernel runs after  host-to-device copy</span></div>
<div class="line">     .<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(d2h_x, d2h_y);  <span class="comment">// kernel runs before device-to-host copy</span></div>
<div class="line"> </div>
<div class="line">cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">offload</a>();  <span class="comment">// offload and run the standalone cudaFlow capturer once</span></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_ab70f12050e78b588f5c23d874aa4e538"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#ab70f12050e78b588f5c23d874aa4e538">tf::cudaFlowCapturer::copy</a></div><div class="ttdeci">cudaTask copy(T *tgt, const T *src, size_t num)</div><div class="ttdoc">captures a copy task of typed data</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1136</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_a4a9ca1a34bac47e4c9b04eb4fb2f7775"><div class="ttname"><a href="classtf_1_1cudaTask.html#a4a9ca1a34bac47e4c9b04eb4fb2f7775">tf::cudaTask::succeed</a></div><div class="ttdeci">cudaTask &amp; succeed(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from other tasks to this</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:189</div></div>
</div><!-- fragment --><p>When using cudaFlow Capturer in a standalone environment, it is your choice to decide its GPU context. The following example creates a cudaFlow capturer and executes it on GPU 2.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1cudaScopedDevice.html">tf::cudaScopedDevice</a> gpu(2);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a> cf;  <span class="comment">// create a standalone cudaFlow capturer on GPU 2</span></div>
<div class="line">cf.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#a5959002af1cf1a1ada3d86a073682232">offload</a>();             <span class="comment">// run the capturer once on GPU 2</span></div>
<div class="ttc" id="aclasstf_1_1cudaScopedDevice_html"><div class="ttname"><a href="classtf_1_1cudaScopedDevice.html">tf::cudaScopedDevice</a></div><div class="ttdoc">class to create an RAII-styled context switch</div><div class="ttdef"><b>Definition</b> cuda_device.hpp:293</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In the standalone mode, a written cudaFlow capturer will not be executed until you explicitly call an offload method, as there is neither a taskflow nor an executor. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Cookbook.html">Cookbook</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
