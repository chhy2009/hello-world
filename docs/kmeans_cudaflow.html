<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Taskflow Handbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/x-icon" href="favicon.ico" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="taskflow_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://taskflow.github.io/">Taskflow</a>
   &#160;<span id="projectnumber">3.2.0-Master-Branch</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('kmeans_cudaflow.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">k-means Clustering (cudaFlow)</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#DefineTheKMeansKernels">Define the k-means Kernels</a></li>
<li class="level1"><a href="#DefineTheKMeanscudaFlow">Define the k-means cudaFlow</a></li>
<li class="level1"><a href="#RepeatTheExecutionofTheKMeanscudaFlow">Repeat the Execution of the k-means cudaFlow</a></li>
<li class="level1"><a href="#KMeanscudaFlowBenchmarking">Benchmarking</a></li>
</ul>
</div>
<div class="textblock"><p>Following up on <a class="el" href="kmeans.html">k-means Clustering</a>, this page studies how to accelerate a k-means workload on a GPU using <a class="el" href="classtf_1_1cudaFlow.html" title="class to create a cudaFlow task dependency graph">tf::cudaFlow</a>.</p>
<h1><a class="anchor" id="DefineTheKMeansKernels"></a>
Define the k-means Kernels</h1>
<p>Recall that the k-means algorithm has the following steps:</p>
<ul>
<li>
Step 1: initialize k random centroids </li>
<li>
Step 2: for every data point, find the nearest centroid (L2 distance or other measurements) and assign the point to it </li>
<li>
Step 3: for every centroid, move the centroid to the average of the points assigned to that centroid </li>
<li>
Step 4: go to Step 2 until converged (no more changes in the last few iterations) or maximum iterations reached </li>
</ul>
<p>We observe Step 2 and Step 3 of the algorithm are parallelizable across individual points for use to harness the power of GPU:</p>
<ol>
<li>
for every data point, find the nearest centroid (L2 distance or other measurements) and assign the point to it </li>
<li>
for every centroid, move the centroid to the average of the points assigned to that centroid. </li>
</ol>
<p>At a fine-grained level, we request one GPU thread to work on one point for Step 2 and one GPU thread to work on one centroid for Step 3.</p>
<div class="fragment"><div class="line"><span class="comment">// px/py: 2D points</span></div>
<div class="line"><span class="comment">// N: number of points</span></div>
<div class="line"><span class="comment">// mx/my: centroids</span></div>
<div class="line"><span class="comment">// K: number of clusters</span></div>
<div class="line"><span class="comment">// sx/sy/c: storage to compute the average</span></div>
<div class="line">__global__ <span class="keywordtype">void</span> assign_clusters(</div>
<div class="line">  <span class="keywordtype">float</span>* px, <span class="keywordtype">float</span>* py, <span class="keywordtype">int</span> N, </div>
<div class="line">  <span class="keywordtype">float</span>* mx, <span class="keywordtype">float</span>* my, <span class="keywordtype">float</span>* sx, <span class="keywordtype">float</span>* sy, <span class="keywordtype">int</span> K, <span class="keywordtype">int</span>* c</div>
<div class="line">) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> index = blockIdx.x * blockDim.x + threadIdx.x;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (index &gt;= N) {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Make global loads once.</span></div>
<div class="line">  <span class="keywordtype">float</span> x = px[index];</div>
<div class="line">  <span class="keywordtype">float</span> y = py[index];</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">float</span> best_dance = FLT_MAX;</div>
<div class="line">  <span class="keywordtype">int</span> best_k = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; K; ++k) {</div>
<div class="line">    <span class="keywordtype">float</span> d = L2(x, y, mx[k], my[k]);</div>
<div class="line">    <span class="keywordflow">if</span> (d &lt; best_d) {</div>
<div class="line">      best_d = d;</div>
<div class="line">      best_k = k;</div>
<div class="line">    }   </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  atomicAdd(&amp;sx[best_k], x); </div>
<div class="line">  atomicAdd(&amp;sy[best_k], y); </div>
<div class="line">  atomicAdd(&amp;c [best_k], 1); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// mx/my: centroids, sx/sy/c: storage to compute the average</span></div>
<div class="line">__global__ <span class="keywordtype">void</span> compute_new_means(</div>
<div class="line">  <span class="keywordtype">float</span>* mx, <span class="keywordtype">float</span>* my, <span class="keywordtype">float</span>* sx, <span class="keywordtype">float</span>* sy, <span class="keywordtype">int</span>* c</div>
<div class="line">) {</div>
<div class="line">  <span class="keywordtype">int</span> k = threadIdx.x;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/algorithm/count.html">count</a> = <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/algorithm/max.html">max</a>(1, c[k]);  <span class="comment">// turn 0/0 to 0/1</span></div>
<div class="line">  mx[k] = sx[k] / <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/algorithm/count.html">count</a>;</div>
<div class="line">  my[k] = sy[k] / <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/algorithm/count.html">count</a>;</div>
<div class="line">}</div>
<div class="ttc" id="acount_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/algorithm/count.html">std::count</a></div><div class="ttdeci">T count(T... args)</div></div>
<div class="ttc" id="amax_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/algorithm/max.html">std::max</a></div><div class="ttdeci">T max(T... args)</div></div>
</div><!-- fragment --><p>When we recompute the cluster centroids to be the mean of all points assigned to a particular centroid, multiple GPU threads may access the sum arrays, <code>sx</code> and <code>sy</code>, and the count array, <code>c</code>. To avoid data race, we use a simple <code>atomicAdd</code> method.</p>
<h1><a class="anchor" id="DefineTheKMeanscudaFlow"></a>
Define the k-means cudaFlow</h1>
<p>Based on the two kernels, we can define the cudaFlow for the k-means workload below:</p>
<div class="fragment"><div class="line"><span class="comment">// N: number of points</span></div>
<div class="line"><span class="comment">// K: number of clusters</span></div>
<div class="line"><span class="comment">// M: number of iterations</span></div>
<div class="line"><span class="comment">// px/py: 2D point vector </span></div>
<div class="line"><span class="keywordtype">void</span> kmeans_gpu(</div>
<div class="line">  <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> K, <span class="keywordtype">int</span> M, cconst <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;float&gt;</a>&amp; px, <span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;float&gt;</a>&amp; py</div>
<div class="line">) {</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;float&gt;</a> h_mx, h_my;</div>
<div class="line">  <span class="keywordtype">float</span> *d_px, *d_py, *d_mx, *d_my, *d_sx, *d_sy, *d_c;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;K; ++i) {</div>
<div class="line">    h_mx.push_back(h_px[i]);</div>
<div class="line">    h_my.push_back(h_py[i]);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create a taskflow graph</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Executor.html">tf::Executor</a> executor;</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Taskflow.html">tf::Taskflow</a> taskflow(<span class="stringliteral">&quot;K-Means&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// allocate GPU memory</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> allocate_px = taskflow.emplace([&amp;](){ </div>
<div class="line">    cudaMalloc(&amp;d_px, N*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)); </div>
<div class="line">  }).name(<span class="stringliteral">&quot;allocate_px&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> allocate_py = taskflow.emplace([&amp;](){ </div>
<div class="line">    cudaMalloc(&amp;d_py, N*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)); </div>
<div class="line">  }).name(<span class="stringliteral">&quot;allocate_py&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> allocate_mx = taskflow.emplace([&amp;](){ </div>
<div class="line">    cudaMalloc(&amp;d_mx, K*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)); }</div>
<div class="line">  ).name(<span class="stringliteral">&quot;allocate_mx&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> allocate_my = taskflow.emplace([&amp;](){ </div>
<div class="line">    cudaMalloc(&amp;d_my, K*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)); </div>
<div class="line">  }).name(<span class="stringliteral">&quot;allocate_my&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> allocate_sy = taskflow.emplace([&amp;](){ </div>
<div class="line">    cudaMalloc(&amp;d_sy, K*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)); </div>
<div class="line">  }).name(<span class="stringliteral">&quot;allocate_sy&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> allocate_c = taskflow.emplace([&amp;](){ </div>
<div class="line">    cudaMalloc(&amp;d_c, K*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)); </div>
<div class="line">  }).name(<span class="stringliteral">&quot;allocate_c&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// transfer data from the host to the GPU</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> h2d = taskflow.emplace([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line">    cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">copy</a>(d_px, h_px.data(), N).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;h2d_px&quot;</span>);</div>
<div class="line">    cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">copy</a>(d_py, h_py.data(), N).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;h2d_py&quot;</span>);</div>
<div class="line">    cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">copy</a>(d_mx, h_mx.data(), K).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;h2d_mx&quot;</span>);</div>
<div class="line">    cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">copy</a>(d_my, h_my.data(), K).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;h2d_my&quot;</span>);</div>
<div class="line">  }).name(<span class="stringliteral">&quot;h2d&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// GPU task graph of the main k-means body</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> kmeans = taskflow.emplace([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> zero_c = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">zero</a>(d_c, K).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;zero_c&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> zero_sx = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">zero</a>(d_sx, K).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;zero_sx&quot;</span>);</div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> zero_sy = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">zero</a>(d_sy, K).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;zero_sy&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> cluster = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(</div>
<div class="line">      (N+1024-1) / 1024, 1024, 0, </div>
<div class="line">      assign_clusters, d_px, d_py, N, d_mx, d_my, d_sx, d_sy, K, d_c</div>
<div class="line">    ).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;cluster&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> new_centroid = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(</div>
<div class="line">      1, K, 0, compute_new_means, d_mx, d_my, d_sx, d_sy, d_c</div>
<div class="line">    ).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;new_centroid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    cluster.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(new_centroid)</div>
<div class="line">           .<a class="code hl_function" href="classtf_1_1cudaTask.html#a4a9ca1a34bac47e4c9b04eb4fb2f7775">succeed</a>(zero_c, zero_sx, zero_sy);</div>
<div class="line">  }).name(<span class="stringliteral">&quot;update_means&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// condition task to check convergence</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> condition = taskflow.emplace([i=0, M] () <span class="keyword">mutable</span> {</div>
<div class="line">    <span class="keywordflow">return</span> i++ &lt; M ? 0 : 1;</div>
<div class="line">  }).name(<span class="stringliteral">&quot;converged?&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// transfer the result of clusters from GPU to host</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> stop = taskflow.emplace([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line">    cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">copy</a>(h_mx.data(), d_mx, K).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;d2h_mx&quot;</span>);</div>
<div class="line">    cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">copy</a>(h_my.data(), d_my, K).<a class="code hl_function" href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">name</a>(<span class="stringliteral">&quot;d2h_my&quot;</span>);</div>
<div class="line">  }).name(<span class="stringliteral">&quot;d2h&quot;</span>);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// deallocated GPU memory</span></div>
<div class="line">  <a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/memory/c/free.html">free</a> = taskflow.emplace([&amp;](){</div>
<div class="line">    cudaFree(d_px);</div>
<div class="line">    cudaFree(d_py);</div>
<div class="line">    cudaFree(d_mx);</div>
<div class="line">    cudaFree(d_my);</div>
<div class="line">    cudaFree(d_sx);</div>
<div class="line">    cudaFree(d_sy);</div>
<div class="line">    cudaFree(d_c);</div>
<div class="line">  }).name(<span class="stringliteral">&quot;free&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// build up the dependency</span></div>
<div class="line">  h2d.<a class="code hl_function" href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">succeed</a>(allocate_px, allocate_py, allocate_mx, allocate_my);</div>
<div class="line"> </div>
<div class="line">  kmeans.<a class="code hl_function" href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">succeed</a>(allocate_sx, allocate_sy, allocate_c, h2d)</div>
<div class="line">        .<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(condition);</div>
<div class="line"> </div>
<div class="line">  condition.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(kmeans, stop);</div>
<div class="line"> </div>
<div class="line">  stop.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(free);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// dump the taskflow without expanding GPU task graphs</span></div>
<div class="line">  taskflow.<a class="code hl_function" href="classtf_1_1Task.html#a3318a49ff9d0a01cd1e8ee675251e3b7">dump</a>(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// run the taskflow</span></div>
<div class="line">  executor.<a class="code hl_function" href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">run</a>(taskflow).wait();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// dump the entire taskflow</span></div>
<div class="line">  taskflow.dump(<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a>);</div>
<div class="line">}</div>
<div class="ttc" id="abasic_ostream_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a></div></div>
<div class="ttc" id="aclasstf_1_1Executor_html"><div class="ttname"><a href="classtf_1_1Executor.html">tf::Executor</a></div><div class="ttdoc">class to create an executor for running a taskflow graph</div><div class="ttdef"><b>Definition</b> executor.hpp:50</div></div>
<div class="ttc" id="aclasstf_1_1Executor_html_a519777f5783981d534e9e53b99712069"><div class="ttname"><a href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">tf::Executor::run</a></div><div class="ttdeci">tf::Future&lt; void &gt; run(Taskflow &amp;taskflow)</div><div class="ttdoc">runs a taskflow once</div><div class="ttdef"><b>Definition</b> executor.hpp:1573</div></div>
<div class="ttc" id="aclasstf_1_1Task_html"><div class="ttname"><a href="classtf_1_1Task.html">tf::Task</a></div><div class="ttdoc">class to create a task handle over a node in a taskflow graph</div><div class="ttdef"><b>Definition</b> task.hpp:187</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_a3318a49ff9d0a01cd1e8ee675251e3b7"><div class="ttname"><a href="classtf_1_1Task.html#a3318a49ff9d0a01cd1e8ee675251e3b7">tf::Task::dump</a></div><div class="ttdeci">void dump(std::ostream &amp;ostream) const</div><div class="ttdoc">dumps the task through an output stream</div><div class="ttdef"><b>Definition</b> task.hpp:573</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_a331b1b726555072e7c7d10941257f664"><div class="ttname"><a href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">tf::Task::succeed</a></div><div class="ttdeci">Task &amp; succeed(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from other tasks to this</div><div class="ttdef"><b>Definition</b> task.hpp:428</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_a8c78c453295a553c1c016e4062da8588"><div class="ttname"><a href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">tf::Task::precede</a></div><div class="ttdeci">Task &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> task.hpp:420</div></div>
<div class="ttc" id="aclasstf_1_1Taskflow_html"><div class="ttname"><a href="classtf_1_1Taskflow.html">tf::Taskflow</a></div><div class="ttdoc">class to create a taskflow object</div><div class="ttdef"><b>Definition</b> core/taskflow.hpp:73</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html"><div class="ttname"><a href="classtf_1_1cudaFlow.html">tf::cudaFlow</a></div><div class="ttdoc">class to create a cudaFlow task dependency graph</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:56</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_a40172fac4464f6d805f75921ea3c2a3b"><div class="ttname"><a href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">tf::cudaFlow::zero</a></div><div class="ttdeci">cudaTask zero(T *dst, size_t count)</div><div class="ttdoc">creates a memset task that sets a typed memory block to zero</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1303</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_aa6e734462c8b8d922f44e621f94b104c"><div class="ttname"><a href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">tf::cudaFlow::kernel</a></div><div class="ttdeci">cudaTask kernel(dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</div><div class="ttdoc">creates a kernel task</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1272</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_af03e04771b655f9e629eb4c22e19b19f"><div class="ttname"><a href="classtf_1_1cudaFlow.html#af03e04771b655f9e629eb4c22e19b19f">tf::cudaFlow::copy</a></div><div class="ttdeci">cudaTask copy(T *tgt, const T *src, size_t num)</div><div class="ttdoc">creates a memcopy task that copies typed data</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1348</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html"><div class="ttname"><a href="classtf_1_1cudaTask.html">tf::cudaTask</a></div><div class="ttdoc">class to create a task handle over an internal node of a cudaFlow graph</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:65</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_a4a9ca1a34bac47e4c9b04eb4fb2f7775"><div class="ttname"><a href="classtf_1_1cudaTask.html#a4a9ca1a34bac47e4c9b04eb4fb2f7775">tf::cudaTask::succeed</a></div><div class="ttdeci">cudaTask &amp; succeed(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from other tasks to this</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:189</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_ab81b4f71a44af8d61758524f0c274962"><div class="ttname"><a href="classtf_1_1cudaTask.html#ab81b4f71a44af8d61758524f0c274962">tf::cudaTask::name</a></div><div class="ttdeci">cudaTask &amp; name(const std::string &amp;name)</div><div class="ttdoc">assigns a name to the task</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:200</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_abdd68287ec4dff4216af34d1db44d1b4"><div class="ttname"><a href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">tf::cudaTask::precede</a></div><div class="ttdeci">cudaTask &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:182</div></div>
<div class="ttc" id="afree_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/memory/c/free.html">std::free</a></div><div class="ttdeci">T free(T... args)</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><p>The first dump before executing the taskflow produces the following diagram. The condition tasks introduces a cycle between itself and <code>update_means</code>. Each time it goes back to <code>update_means</code>, the cudaFlow is reconstructed with captured parameters in the closure and offloaded to the GPU.</p>
<div class="dotgraph">
<img src="dot_kmeans_3.png" alt="dot_kmeans_3.png" border="0" usemap="#dot_kmeans_3.map"/>
</div>
<p>The second dump after executing the taskflow produces the following diagram, with all cudaFlows expanded:</p>
<div class="dotgraph">
<img src="dot_kmeans_4.png" alt="dot_kmeans_4.png" border="0" usemap="#dot_kmeans_4.map"/>
</div>
<p>The main cudaFlow task, <code>update_means</code>, must not run before all required data has settled down. It precedes a condition task that circles back to itself until we reach <code>M</code> iterations. When iteration completes, the condition task directs the execution path to the cudaFlow, <code>h2d</code>, to copy the results of clusters to <code>h_mx</code> and <code>h_my</code> and then deallocate all GPU memory.</p>
<h1><a class="anchor" id="RepeatTheExecutionofTheKMeanscudaFlow"></a>
Repeat the Execution of the k-means cudaFlow</h1>
<p>We observe the GPU task graph parameters remain <em>unchanged</em> across all k-means iterations. In this case, we can leverage <a class="el" href="classtf_1_1cudaFlow.html#a99358da15e3bdfa1faabb3e326130e1f" title="offloads the cudaFlow onto a GPU and repeatedly runs it until the predicate becomes true">tf::cudaFlow::offload_until</a> or <a class="el" href="classtf_1_1cudaFlow.html#ac2269fd7dc8ca04a294a718204703dad" title="offloads the cudaFlow and executes it by the given times">tf::cudaFlow::offload_n</a> to run it repeatedly without conditional tasking.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> kmeans = taskflow.emplace([&amp;](<a class="code hl_class" href="classtf_1_1cudaFlow.html">tf::cudaFlow</a>&amp; cf){</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> zero_c = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">zero</a>(d_c, K).name(<span class="stringliteral">&quot;zero_c&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> zero_sx = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">zero</a>(d_sx, K).name(<span class="stringliteral">&quot;zero_sx&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> zero_sy = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#a40172fac4464f6d805f75921ea3c2a3b">zero</a>(d_sy, K).name(<span class="stringliteral">&quot;zero_sy&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> cluster = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(</div>
<div class="line">    (N+1024-1) / 1024, 1024, 0,</div>
<div class="line">    assign_clusters, d_px, d_py, N, d_mx, d_my, d_sx, d_sy, K, d_c</div>
<div class="line">  ).name(<span class="stringliteral">&quot;cluster&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classtf_1_1cudaTask.html">tf::cudaTask</a> new_centroid = cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#aa6e734462c8b8d922f44e621f94b104c">kernel</a>(</div>
<div class="line">    1, K, 0,</div>
<div class="line">    compute_new_means, d_mx, d_my, d_sx, d_sy, d_c</div>
<div class="line">  ).name(<span class="stringliteral">&quot;new_centroid&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  cluster.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(new_centroid)</div>
<div class="line">         .succeed(zero_c, zero_sx, zero_sy);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// we ask the executor to launch the cudaFlow by M times</span></div>
<div class="line">  cf.<a class="code hl_function" href="classtf_1_1cudaFlow.html#ac2269fd7dc8ca04a294a718204703dad">offload_n</a>(M);</div>
<div class="line">}).name(<span class="stringliteral">&quot;update_means&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// build up the dependency</span></div>
<div class="line">h2d.<a class="code hl_function" href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">succeed</a>(allocate_px, allocate_py, allocate_mx, allocate_my);</div>
<div class="line"> </div>
<div class="line">kmeans.<a class="code hl_function" href="classtf_1_1Task.html#a331b1b726555072e7c7d10941257f664">succeed</a>(allocate_sx, allocate_sy, allocate_c, h2d)</div>
<div class="line">      .<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(stop);</div>
<div class="line"> </div>
<div class="line">stop.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(free);</div>
<div class="ttc" id="aclasstf_1_1cudaFlow_html_ac2269fd7dc8ca04a294a718204703dad"><div class="ttname"><a href="classtf_1_1cudaFlow.html#ac2269fd7dc8ca04a294a718204703dad">tf::cudaFlow::offload_n</a></div><div class="ttdeci">void offload_n(size_t N)</div><div class="ttdoc">offloads the cudaFlow and executes it by the given times</div><div class="ttdef"><b>Definition</b> cudaflow.hpp:1649</div></div>
</div><!-- fragment --><p>At the last line of the cudaFlow closure, we call <code>cf.offload_n(M)</code> to ask the executor to repeatedly run the cudaFlow by <code>M</code> times. Compared with the version using conditional tasking, the cudaFlow here is created only one time and thus the overhead is reduced.</p>
<div class="dotgraph">
<img src="dot_kmeans_5.png" alt="dot_kmeans_5.png" border="0" usemap="#dot_kmeans_5.map"/>
</div>
<p>We can see from the above taskflow the condition task is removed.</p>
<h1><a class="anchor" id="KMeanscudaFlowBenchmarking"></a>
Benchmarking</h1>
<p>We run three versions of k-means, sequential CPU, parallel CPUs, and one GPU, on a machine of 12 Intel i7-8700 CPUs at 3.20 GHz and a Nvidia RTX 2080 GPU using various numbers of 2D point counts and iterations.</p>
<div align="center"> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">N   </th><th class="markdownTableHeadCenter">K   </th><th class="markdownTableHeadCenter">M   </th><th class="markdownTableHeadCenter">CPU Sequential   </th><th class="markdownTableHeadCenter">CPU Parallel   </th><th class="markdownTableHeadCenter">GPU (conditional taksing)   </th><th class="markdownTableHeadCenter">GPU (using offload_n)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">5   </td><td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">0.14 ms   </td><td class="markdownTableBodyCenter">77 ms   </td><td class="markdownTableBodyCenter">1 ms   </td><td class="markdownTableBodyCenter">1 ms    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">100   </td><td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">100   </td><td class="markdownTableBodyCenter">0.56 ms   </td><td class="markdownTableBodyCenter">86 ms   </td><td class="markdownTableBodyCenter">7 ms   </td><td class="markdownTableBodyCenter">1 ms    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1000   </td><td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">1000   </td><td class="markdownTableBodyCenter">10 ms   </td><td class="markdownTableBodyCenter">98 ms   </td><td class="markdownTableBodyCenter">55 ms   </td><td class="markdownTableBodyCenter">13 ms    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">10000   </td><td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">10000   </td><td class="markdownTableBodyCenter">1006 ms   </td><td class="markdownTableBodyCenter">713 ms   </td><td class="markdownTableBodyCenter">458 ms   </td><td class="markdownTableBodyCenter">183 ms    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">100000   </td><td class="markdownTableBodyCenter">10   </td><td class="markdownTableBodyCenter">100000   </td><td class="markdownTableBodyCenter">102483 ms   </td><td class="markdownTableBodyCenter">49966 ms   </td><td class="markdownTableBodyCenter">7952 ms   </td><td class="markdownTableBodyCenter">4725 ms   </td></tr>
</table>
</div><p>When the number of points is larger than 10K, both parallel CPU and GPU implementations start to pick up the speed over than the sequential version. We can see that using the built-in predicate, <a class="el" href="classtf_1_1cudaFlow.html#ac2269fd7dc8ca04a294a718204703dad" title="offloads the cudaFlow and executes it by the given times">tf::cudaFlow::offload_n</a>, can avoid repetitively creating the graph over and over, resulting in two times faster than conditional tasking. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Examples.html">Learning from Examples</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
