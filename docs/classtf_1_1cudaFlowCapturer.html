<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Taskflow Handbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/x-icon" href="favicon.ico" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="taskflow_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://taskflow.github.io/">Taskflow</a>
   &#160;<span id="projectnumber">3.2.0-Master-Branch</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtf_1_1cudaFlowCapturer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtf_1_1cudaFlowCapturer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tf::cudaFlowCapturer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>class to create a cudaFlow graph using stream capture  
 <a href="classtf_1_1cudaFlowCapturer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cuda__capturer_8hpp_source.html">cuda_capturer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab413b88bf73368f1e6dd98d19016bbc" id="r_aab413b88bf73368f1e6dd98d19016bbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#aab413b88bf73368f1e6dd98d19016bbc">cudaFlowCapturer</a> ()</td></tr>
<tr class="memdesc:aab413b88bf73368f1e6dd98d19016bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">constrcts a standalone <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">cudaFlowCapturer</a>  <br /></td></tr>
<tr class="separator:aab413b88bf73368f1e6dd98d19016bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f3765cd2cd7368522011d37a294359" id="r_ab2f3765cd2cd7368522011d37a294359"><td class="memItemLeft" align="right" valign="top"><a id="ab2f3765cd2cd7368522011d37a294359" name="ab2f3765cd2cd7368522011d37a294359"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~cudaFlowCapturer</b> ()</td></tr>
<tr class="memdesc:ab2f3765cd2cd7368522011d37a294359"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructs the <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">cudaFlowCapturer</a> <br /></td></tr>
<tr class="separator:ab2f3765cd2cd7368522011d37a294359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3413a20a7c8229365e1ee9fb5af4af1e" id="r_a3413a20a7c8229365e1ee9fb5af4af1e"><td class="memItemLeft" align="right" valign="top"><a id="a3413a20a7c8229365e1ee9fb5af4af1e" name="a3413a20a7c8229365e1ee9fb5af4af1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a3413a20a7c8229365e1ee9fb5af4af1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the emptiness of the graph <br /></td></tr>
<tr class="separator:a3413a20a7c8229365e1ee9fb5af4af1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb826786f1580bae1335d94ffbeb7e02" id="r_aeb826786f1580bae1335d94ffbeb7e02"><td class="memItemLeft" align="right" valign="top"><a id="aeb826786f1580bae1335d94ffbeb7e02" name="aeb826786f1580bae1335d94ffbeb7e02"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_tasks</b> () const</td></tr>
<tr class="memdesc:aeb826786f1580bae1335d94ffbeb7e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the number of tasks <br /></td></tr>
<tr class="separator:aeb826786f1580bae1335d94ffbeb7e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f1176b6a5590832f0e09a049f8a622" id="r_a06f1176b6a5590832f0e09a049f8a622"><td class="memItemLeft" align="right" valign="top"><a id="a06f1176b6a5590832f0e09a049f8a622" name="a06f1176b6a5590832f0e09a049f8a622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a06f1176b6a5590832f0e09a049f8a622"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear this cudaFlow capturer <br /></td></tr>
<tr class="separator:a06f1176b6a5590832f0e09a049f8a622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d1265bcc27647906bed6e6876c9aa7" id="r_a90d1265bcc27647906bed6e6876c9aa7"><td class="memItemLeft" align="right" valign="top"><a id="a90d1265bcc27647906bed6e6876c9aa7" name="a90d1265bcc27647906bed6e6876c9aa7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os) const</td></tr>
<tr class="memdesc:a90d1265bcc27647906bed6e6876c9aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumps the capture graph into a DOT format through an output stream <br /></td></tr>
<tr class="separator:a90d1265bcc27647906bed6e6876c9aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d016b56c06cb28eabfebfdd7dbb24d" id="r_aa1d016b56c06cb28eabfebfdd7dbb24d"><td class="memTemplParams" colspan="2">template&lt;typename OPT , typename... ArgsT&gt; </td></tr>
<tr class="memitem:aa1d016b56c06cb28eabfebfdd7dbb24d"><td class="memTemplItemLeft" align="right" valign="top">OPT &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#aa1d016b56c06cb28eabfebfdd7dbb24d">make_optimizer</a> (ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa1d016b56c06cb28eabfebfdd7dbb24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">selects a different optimization algorithm  <br /></td></tr>
<tr class="separator:aa1d016b56c06cb28eabfebfdd7dbb24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d937ae0d77239f148b66a77e35db41" id="r_ad0d937ae0d77239f148b66a77e35db41"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_invocable_r_v</a>&lt; void, C, cudaStream_t &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad0d937ae0d77239f148b66a77e35db41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a> (C &amp;&amp;callable)</td></tr>
<tr class="memdesc:ad0d937ae0d77239f148b66a77e35db41"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a sequential CUDA operations from the given callable  <br /></td></tr>
<tr class="separator:ad0d937ae0d77239f148b66a77e35db41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5215d459df3a0d7bccac1a1f2ce9d1ee" id="r_a5215d459df3a0d7bccac1a1f2ce9d1ee"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_invocable_r_v</a>&lt; void, C, cudaStream_t &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5215d459df3a0d7bccac1a1f2ce9d1ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a5215d459df3a0d7bccac1a1f2ce9d1ee">on</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a5215d459df3a0d7bccac1a1f2ce9d1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to another sequential CUDA operations  <br /></td></tr>
<tr class="separator:a5215d459df3a0d7bccac1a1f2ce9d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593335760ea517cea597237137ef9333" id="r_a593335760ea517cea597237137ef9333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a593335760ea517cea597237137ef9333">noop</a> ()</td></tr>
<tr class="memdesc:a593335760ea517cea597237137ef9333"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a no-operation task  <br /></td></tr>
<tr class="separator:a593335760ea517cea597237137ef9333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168a968d7f5833700fcc14a210ad39bc" id="r_a168a968d7f5833700fcc14a210ad39bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a168a968d7f5833700fcc14a210ad39bc">noop</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task)</td></tr>
<tr class="memdesc:a168a968d7f5833700fcc14a210ad39bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a task to a no-operation task  <br /></td></tr>
<tr class="separator:a168a968d7f5833700fcc14a210ad39bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84d097cdae9e2e8ce108dea760483ed" id="r_ae84d097cdae9e2e8ce108dea760483ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ae84d097cdae9e2e8ce108dea760483ed">memcpy</a> (void *dst, const void *src, size_t count)</td></tr>
<tr class="memdesc:ae84d097cdae9e2e8ce108dea760483ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies data between host and device asynchronously through a stream  <br /></td></tr>
<tr class="separator:ae84d097cdae9e2e8ce108dea760483ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20db64e086bf8182b350eaf5d8807af9" id="r_a20db64e086bf8182b350eaf5d8807af9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a20db64e086bf8182b350eaf5d8807af9">memcpy</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, void *dst, const void *src, size_t count)</td></tr>
<tr class="memdesc:a20db64e086bf8182b350eaf5d8807af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a memcpy operation  <br /></td></tr>
<tr class="separator:a20db64e086bf8182b350eaf5d8807af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70f12050e78b588f5c23d874aa4e538" id="r_ab70f12050e78b588f5c23d874aa4e538"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab70f12050e78b588f5c23d874aa4e538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ab70f12050e78b588f5c23d874aa4e538">copy</a> (T *tgt, const T *src, size_t num)</td></tr>
<tr class="memdesc:ab70f12050e78b588f5c23d874aa4e538"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a copy task of typed data  <br /></td></tr>
<tr class="separator:ab70f12050e78b588f5c23d874aa4e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f9dfd1363e10d08cbdab29f59a52e" id="r_a605f9dfd1363e10d08cbdab29f59a52e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a605f9dfd1363e10d08cbdab29f59a52e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a605f9dfd1363e10d08cbdab29f59a52e">copy</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, T *tgt, const T *src, size_t num)</td></tr>
<tr class="memdesc:a605f9dfd1363e10d08cbdab29f59a52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a copy operation  <br /></td></tr>
<tr class="separator:a605f9dfd1363e10d08cbdab29f59a52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d38965b380f940bf6cfc6667a281052" id="r_a0d38965b380f940bf6cfc6667a281052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a0d38965b380f940bf6cfc6667a281052">memset</a> (void *ptr, int v, size_t n)</td></tr>
<tr class="memdesc:a0d38965b380f940bf6cfc6667a281052"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes or sets GPU memory to the given value byte by byte  <br /></td></tr>
<tr class="separator:a0d38965b380f940bf6cfc6667a281052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7c4dd81f5e00e8a4c733417bca3205" id="r_a4a7c4dd81f5e00e8a4c733417bca3205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a4a7c4dd81f5e00e8a4c733417bca3205">memset</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, void *ptr, int value, size_t n)</td></tr>
<tr class="memdesc:a4a7c4dd81f5e00e8a4c733417bca3205"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a memset operation  <br /></td></tr>
<tr class="separator:a4a7c4dd81f5e00e8a4c733417bca3205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06c7f6954d8d67ad89f0eddfe285e9" id="r_a6f06c7f6954d8d67ad89f0eddfe285e9"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:a6f06c7f6954d8d67ad89f0eddfe285e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a6f06c7f6954d8d67ad89f0eddfe285e9">kernel</a> (dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6f06c7f6954d8d67ad89f0eddfe285e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a kernel  <br /></td></tr>
<tr class="separator:a6f06c7f6954d8d67ad89f0eddfe285e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850c7c028e1535db1deaecd819d82efb" id="r_a850c7c028e1535db1deaecd819d82efb"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:a850c7c028e1535db1deaecd819d82efb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a850c7c028e1535db1deaecd819d82efb">kernel</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, dim3 g, dim3 b, size_t s, F f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:a850c7c028e1535db1deaecd819d82efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a kernel operation  <br /></td></tr>
<tr class="separator:a850c7c028e1535db1deaecd819d82efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac944c7d20056e0633ef84f1a25b52296" id="r_ac944c7d20056e0633ef84f1a25b52296"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ac944c7d20056e0633ef84f1a25b52296"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ac944c7d20056e0633ef84f1a25b52296">single_task</a> (C c)</td></tr>
<tr class="memdesc:ac944c7d20056e0633ef84f1a25b52296"><td class="mdescLeft">&#160;</td><td class="mdescRight">capturers a kernel to runs the given callable with only one thread  <br /></td></tr>
<tr class="separator:ac944c7d20056e0633ef84f1a25b52296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7e439c336aa43781c3ef1ef0d71154" id="r_a2f7e439c336aa43781c3ef1ef0d71154"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a2f7e439c336aa43781c3ef1ef0d71154"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a2f7e439c336aa43781c3ef1ef0d71154">single_task</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, C c)</td></tr>
<tr class="memdesc:a2f7e439c336aa43781c3ef1ef0d71154"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a single-threaded kernel  <br /></td></tr>
<tr class="separator:a2f7e439c336aa43781c3ef1ef0d71154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2f1bcd59f0b42e0f823818348b4ae7" id="r_a0b2f1bcd59f0b42e0f823818348b4ae7"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a0b2f1bcd59f0b42e0f823818348b4ae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a0b2f1bcd59f0b42e0f823818348b4ae7">for_each</a> (I first, I last, C callable)</td></tr>
<tr class="memdesc:a0b2f1bcd59f0b42e0f823818348b4ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a kernel that applies a callable to each dereferenced element of the data array  <br /></td></tr>
<tr class="separator:a0b2f1bcd59f0b42e0f823818348b4ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17471b99db619c5a6b4645b3dffebe20" id="r_a17471b99db619c5a6b4645b3dffebe20"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a17471b99db619c5a6b4645b3dffebe20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a17471b99db619c5a6b4645b3dffebe20">for_each</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, C callable)</td></tr>
<tr class="memdesc:a17471b99db619c5a6b4645b3dffebe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a for-each kernel task  <br /></td></tr>
<tr class="separator:a17471b99db619c5a6b4645b3dffebe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb877f42ee3a627c40f1c9c84e31ba3c" id="r_aeb877f42ee3a627c40f1c9c84e31ba3c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:aeb877f42ee3a627c40f1c9c84e31ba3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#aeb877f42ee3a627c40f1c9c84e31ba3c">for_each_index</a> (I first, I last, I step, C callable)</td></tr>
<tr class="memdesc:aeb877f42ee3a627c40f1c9c84e31ba3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a kernel that applies a callable to each index in the range with the step size  <br /></td></tr>
<tr class="separator:aeb877f42ee3a627c40f1c9c84e31ba3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ca5fb4d005f1ff05fd1e4312fcd357" id="r_a05ca5fb4d005f1ff05fd1e4312fcd357"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a05ca5fb4d005f1ff05fd1e4312fcd357"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a05ca5fb4d005f1ff05fd1e4312fcd357">for_each_index</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, I step, C callable)</td></tr>
<tr class="memdesc:a05ca5fb4d005f1ff05fd1e4312fcd357"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a for-each-index kernel task  <br /></td></tr>
<tr class="separator:a05ca5fb4d005f1ff05fd1e4312fcd357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d9a86a7240ebf0767441e4ec2e14c4" id="r_a99d9a86a7240ebf0767441e4ec2e14c4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a99d9a86a7240ebf0767441e4ec2e14c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a99d9a86a7240ebf0767441e4ec2e14c4">transform</a> (I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a99d9a86a7240ebf0767441e4ec2e14c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a kernel that transforms an input range to an output range  <br /></td></tr>
<tr class="separator:a99d9a86a7240ebf0767441e4ec2e14c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa62195f91702a6f5cbdad6fefb97e4c" id="r_afa62195f91702a6f5cbdad6fefb97e4c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:afa62195f91702a6f5cbdad6fefb97e4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#afa62195f91702a6f5cbdad6fefb97e4c">transform</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, C op)</td></tr>
<tr class="memdesc:afa62195f91702a6f5cbdad6fefb97e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a transform kernel task  <br /></td></tr>
<tr class="separator:afa62195f91702a6f5cbdad6fefb97e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f527e57e8fe447b9f13ba51e9b9c48" id="r_ac2f527e57e8fe447b9f13ba51e9b9c48"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 , typename O , typename C &gt; </td></tr>
<tr class="memitem:ac2f527e57e8fe447b9f13ba51e9b9c48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ac2f527e57e8fe447b9f13ba51e9b9c48">transform</a> (I1 first1, I1 last1, I2 first2, O output, C op)</td></tr>
<tr class="memdesc:ac2f527e57e8fe447b9f13ba51e9b9c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures a kernel that transforms two input ranges to an output range  <br /></td></tr>
<tr class="separator:ac2f527e57e8fe447b9f13ba51e9b9c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568dcdd226d7e466e2ee106fcdde5db9" id="r_a568dcdd226d7e466e2ee106fcdde5db9"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename I2 , typename O , typename C &gt; </td></tr>
<tr class="memitem:a568dcdd226d7e466e2ee106fcdde5db9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a568dcdd226d7e466e2ee106fcdde5db9">transform</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I1 first1, I1 last1, I2 first2, O output, C op)</td></tr>
<tr class="memdesc:a568dcdd226d7e466e2ee106fcdde5db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a transform kernel task  <br /></td></tr>
<tr class="separator:a568dcdd226d7e466e2ee106fcdde5db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326516e69ca7a1b15aad237428990791" id="r_a326516e69ca7a1b15aad237428990791"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C &gt; </td></tr>
<tr class="memitem:a326516e69ca7a1b15aad237428990791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a326516e69ca7a1b15aad237428990791">reduce</a> (I first, I last, T *result, C op)</td></tr>
<tr class="memdesc:a326516e69ca7a1b15aad237428990791"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that perform parallel reduction over a range of items  <br /></td></tr>
<tr class="separator:a326516e69ca7a1b15aad237428990791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f9dc0d7ba570ee29709ecd14ce4ba8" id="r_ac4f9dc0d7ba570ee29709ecd14ce4ba8"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C &gt; </td></tr>
<tr class="memitem:ac4f9dc0d7ba570ee29709ecd14ce4ba8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ac4f9dc0d7ba570ee29709ecd14ce4ba8">reduce</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, T *result, C op)</td></tr>
<tr class="memdesc:ac4f9dc0d7ba570ee29709ecd14ce4ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a reduction task  <br /></td></tr>
<tr class="separator:ac4f9dc0d7ba570ee29709ecd14ce4ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99044cf477b1bd23c120eb8beea28eea" id="r_a99044cf477b1bd23c120eb8beea28eea"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C &gt; </td></tr>
<tr class="memitem:a99044cf477b1bd23c120eb8beea28eea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a99044cf477b1bd23c120eb8beea28eea">uninitialized_reduce</a> (I first, I last, T *result, C op)</td></tr>
<tr class="memdesc:a99044cf477b1bd23c120eb8beea28eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a326516e69ca7a1b15aad237428990791" title="captures kernels that perform parallel reduction over a range of items">tf::cudaFlowCapturer::reduce</a> but does not assume any initial value to reduce  <br /></td></tr>
<tr class="separator:a99044cf477b1bd23c120eb8beea28eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc9781981da6a26bdff08e015d1260b" id="r_a8bc9781981da6a26bdff08e015d1260b"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C &gt; </td></tr>
<tr class="memitem:a8bc9781981da6a26bdff08e015d1260b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a8bc9781981da6a26bdff08e015d1260b">uninitialized_reduce</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, T *result, C op)</td></tr>
<tr class="memdesc:a8bc9781981da6a26bdff08e015d1260b"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to an uninitialized-reduction task  <br /></td></tr>
<tr class="separator:a8bc9781981da6a26bdff08e015d1260b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02045cacdcff36864243aa9ca0c1d2ef" id="r_a02045cacdcff36864243aa9ca0c1d2ef"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C , typename U &gt; </td></tr>
<tr class="memitem:a02045cacdcff36864243aa9ca0c1d2ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a02045cacdcff36864243aa9ca0c1d2ef">transform_reduce</a> (I first, I last, T *result, C bop, U uop)</td></tr>
<tr class="memdesc:a02045cacdcff36864243aa9ca0c1d2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that perform parallel reduction over a range of transformed items  <br /></td></tr>
<tr class="separator:a02045cacdcff36864243aa9ca0c1d2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba604ae11261bbc2e6b19d79a28157f" id="r_a3ba604ae11261bbc2e6b19d79a28157f"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C , typename U &gt; </td></tr>
<tr class="memitem:a3ba604ae11261bbc2e6b19d79a28157f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a3ba604ae11261bbc2e6b19d79a28157f">transform_reduce</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, T *result, C bop, U uop)</td></tr>
<tr class="memdesc:a3ba604ae11261bbc2e6b19d79a28157f"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a transform-reduce task  <br /></td></tr>
<tr class="separator:a3ba604ae11261bbc2e6b19d79a28157f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4247db18b90679eccb5a1f64743f8577" id="r_a4247db18b90679eccb5a1f64743f8577"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C , typename U &gt; </td></tr>
<tr class="memitem:a4247db18b90679eccb5a1f64743f8577"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a4247db18b90679eccb5a1f64743f8577">transform_uninitialized_reduce</a> (I first, I last, T *result, C bop, U uop)</td></tr>
<tr class="memdesc:a4247db18b90679eccb5a1f64743f8577"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a02045cacdcff36864243aa9ca0c1d2ef" title="captures kernels that perform parallel reduction over a range of transformed items">tf::cudaFlowCapturer::transform_reduce</a> but does not assume any initial value to reduce  <br /></td></tr>
<tr class="separator:a4247db18b90679eccb5a1f64743f8577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fb659f36f0087f880e38f614d224e1" id="r_ab4fb659f36f0087f880e38f614d224e1"><td class="memTemplParams" colspan="2">template&lt;typename I , typename T , typename C , typename U &gt; </td></tr>
<tr class="memitem:ab4fb659f36f0087f880e38f614d224e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ab4fb659f36f0087f880e38f614d224e1">transform_uninitialized_reduce</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, T *result, C bop, U uop)</td></tr>
<tr class="memdesc:ab4fb659f36f0087f880e38f614d224e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a transform-reduce task of no initialized value  <br /></td></tr>
<tr class="separator:ab4fb659f36f0087f880e38f614d224e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c25aef3adbbc8eca69f8857161509c" id="r_a67c25aef3adbbc8eca69f8857161509c"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a67c25aef3adbbc8eca69f8857161509c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a67c25aef3adbbc8eca69f8857161509c">inclusive_scan</a> (I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a67c25aef3adbbc8eca69f8857161509c"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that perform parallel inclusive scan over a range of items  <br /></td></tr>
<tr class="separator:a67c25aef3adbbc8eca69f8857161509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc217d04107eda6f93b1ae9b52171106" id="r_acc217d04107eda6f93b1ae9b52171106"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:acc217d04107eda6f93b1ae9b52171106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#acc217d04107eda6f93b1ae9b52171106">inclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, C op)</td></tr>
<tr class="memdesc:acc217d04107eda6f93b1ae9b52171106"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to an inclusive scan task  <br /></td></tr>
<tr class="separator:acc217d04107eda6f93b1ae9b52171106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9e4fc3b08a74dce4adb0f10c75eaf3" id="r_a2c9e4fc3b08a74dce4adb0f10c75eaf3"><td class="memTemplParams" colspan="2"><a id="a2c9e4fc3b08a74dce4adb0f10c75eaf3" name="a2c9e4fc3b08a74dce4adb0f10c75eaf3"></a>
template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a2c9e4fc3b08a74dce4adb0f10c75eaf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan</b> (I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a2c9e4fc3b08a74dce4adb0f10c75eaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a67c25aef3adbbc8eca69f8857161509c" title="captures kernels that perform parallel inclusive scan over a range of items">cudaFlowCapturer::inclusive_scan</a> but excludes the first value <br /></td></tr>
<tr class="separator:a2c9e4fc3b08a74dce4adb0f10c75eaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e039a9df87a3aa07069abbf9565280a" id="r_a1e039a9df87a3aa07069abbf9565280a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename C &gt; </td></tr>
<tr class="memitem:a1e039a9df87a3aa07069abbf9565280a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a1e039a9df87a3aa07069abbf9565280a">exclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, C op)</td></tr>
<tr class="memdesc:a1e039a9df87a3aa07069abbf9565280a"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to an exclusive scan task  <br /></td></tr>
<tr class="separator:a1e039a9df87a3aa07069abbf9565280a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a36ae28d5844cf281b1d351c359b1af" id="r_a5a36ae28d5844cf281b1d351c359b1af"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:a5a36ae28d5844cf281b1d351c359b1af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a5a36ae28d5844cf281b1d351c359b1af">transform_inclusive_scan</a> (I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:a5a36ae28d5844cf281b1d351c359b1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that perform parallel inclusive scan over a range of transformed items  <br /></td></tr>
<tr class="separator:a5a36ae28d5844cf281b1d351c359b1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdc5bbeeadf0cd1e06c10aa60ec3200" id="r_a4cdc5bbeeadf0cd1e06c10aa60ec3200"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:a4cdc5bbeeadf0cd1e06c10aa60ec3200"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a4cdc5bbeeadf0cd1e06c10aa60ec3200">transform_inclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:a4cdc5bbeeadf0cd1e06c10aa60ec3200"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a transform-inclusive scan task  <br /></td></tr>
<tr class="separator:a4cdc5bbeeadf0cd1e06c10aa60ec3200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bc91e5f13fda5f119d9b9f5f679782" id="r_a91bc91e5f13fda5f119d9b9f5f679782"><td class="memTemplParams" colspan="2"><a id="a91bc91e5f13fda5f119d9b9f5f679782" name="a91bc91e5f13fda5f119d9b9f5f679782"></a>
template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:a91bc91e5f13fda5f119d9b9f5f679782"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_exclusive_scan</b> (I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:a91bc91e5f13fda5f119d9b9f5f679782"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a5a36ae28d5844cf281b1d351c359b1af" title="captures kernels that perform parallel inclusive scan over a range of transformed items">cudaFlowCapturer::transform_inclusive_scan</a> but excludes the first value <br /></td></tr>
<tr class="separator:a91bc91e5f13fda5f119d9b9f5f679782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a98445624773892048399fca219df05" id="r_a4a98445624773892048399fca219df05"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename B , typename U &gt; </td></tr>
<tr class="memitem:a4a98445624773892048399fca219df05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a4a98445624773892048399fca219df05">transform_exclusive_scan</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, O output, B bop, U uop)</td></tr>
<tr class="memdesc:a4a98445624773892048399fca219df05"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a transform-exclusive scan task  <br /></td></tr>
<tr class="separator:a4a98445624773892048399fca219df05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eec500f313481926197ff0b3aed343" id="r_ac2eec500f313481926197ff0b3aed343"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename Comp &gt; </td></tr>
<tr class="memitem:ac2eec500f313481926197ff0b3aed343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ac2eec500f313481926197ff0b3aed343">merge</a> (A a_first, A a_last, B b_first, B b_last, C c_first, Comp comp)</td></tr>
<tr class="memdesc:ac2eec500f313481926197ff0b3aed343"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that perform parallel merge on two sorted arrays  <br /></td></tr>
<tr class="separator:ac2eec500f313481926197ff0b3aed343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a69fa9de723f703d6d69fc96fdc978f" id="r_a4a69fa9de723f703d6d69fc96fdc978f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename Comp &gt; </td></tr>
<tr class="memitem:a4a69fa9de723f703d6d69fc96fdc978f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a4a69fa9de723f703d6d69fc96fdc978f">merge</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, A a_first, A a_last, B b_first, B b_last, C c_first, Comp comp)</td></tr>
<tr class="memdesc:a4a69fa9de723f703d6d69fc96fdc978f"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a merge task  <br /></td></tr>
<tr class="separator:a4a69fa9de723f703d6d69fc96fdc978f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abf795a03b5431c105a70cee4cf5051" id="r_a2abf795a03b5431c105a70cee4cf5051"><td class="memTemplParams" colspan="2">template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </td></tr>
<tr class="memitem:a2abf795a03b5431c105a70cee4cf5051"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a2abf795a03b5431c105a70cee4cf5051">merge_by_key</a> (a_keys_it a_keys_first, a_keys_it a_keys_last, a_vals_it a_vals_first, b_keys_it b_keys_first, b_keys_it b_keys_last, b_vals_it b_vals_first, c_keys_it c_keys_first, c_vals_it c_vals_first, C comp)</td></tr>
<tr class="memdesc:a2abf795a03b5431c105a70cee4cf5051"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that perform parallel key-value merge  <br /></td></tr>
<tr class="separator:a2abf795a03b5431c105a70cee4cf5051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941bd8141ab25430a264041b9dfd6c28" id="r_a941bd8141ab25430a264041b9dfd6c28"><td class="memTemplParams" colspan="2">template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </td></tr>
<tr class="memitem:a941bd8141ab25430a264041b9dfd6c28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a941bd8141ab25430a264041b9dfd6c28">merge_by_key</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, a_keys_it a_keys_first, a_keys_it a_keys_last, a_vals_it a_vals_first, b_keys_it b_keys_first, b_keys_it b_keys_last, b_vals_it b_vals_first, c_keys_it c_keys_first, c_vals_it c_vals_first, C comp)</td></tr>
<tr class="memdesc:a941bd8141ab25430a264041b9dfd6c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a key-value merge task  <br /></td></tr>
<tr class="separator:a941bd8141ab25430a264041b9dfd6c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcb91eb1579451ece602206f20845f4" id="r_a3bcb91eb1579451ece602206f20845f4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a3bcb91eb1579451ece602206f20845f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a3bcb91eb1579451ece602206f20845f4">sort</a> (I first, I last, C comp)</td></tr>
<tr class="memdesc:a3bcb91eb1579451ece602206f20845f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that sort the given array  <br /></td></tr>
<tr class="separator:a3bcb91eb1579451ece602206f20845f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75851fb2e6825dad5143ee3d4bf16411" id="r_a75851fb2e6825dad5143ee3d4bf16411"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C &gt; </td></tr>
<tr class="memitem:a75851fb2e6825dad5143ee3d4bf16411"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a75851fb2e6825dad5143ee3d4bf16411">sort</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, C comp)</td></tr>
<tr class="memdesc:a75851fb2e6825dad5143ee3d4bf16411"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a sort task  <br /></td></tr>
<tr class="separator:a75851fb2e6825dad5143ee3d4bf16411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d2e6ba2eca8ad35a5257e7aedc568f" id="r_ac1d2e6ba2eca8ad35a5257e7aedc568f"><td class="memTemplParams" colspan="2">template&lt;typename K_it , typename V_it , typename C &gt; </td></tr>
<tr class="memitem:ac1d2e6ba2eca8ad35a5257e7aedc568f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ac1d2e6ba2eca8ad35a5257e7aedc568f">sort_by_key</a> (K_it k_first, K_it k_last, V_it v_first, C comp)</td></tr>
<tr class="memdesc:ac1d2e6ba2eca8ad35a5257e7aedc568f"><td class="mdescLeft">&#160;</td><td class="mdescRight">captures kernels that sort the given array  <br /></td></tr>
<tr class="separator:ac1d2e6ba2eca8ad35a5257e7aedc568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353174f6b5bd7707b860280e89486db0" id="r_a353174f6b5bd7707b860280e89486db0"><td class="memTemplParams" colspan="2">template&lt;typename K_it , typename V_it , typename C &gt; </td></tr>
<tr class="memitem:a353174f6b5bd7707b860280e89486db0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a353174f6b5bd7707b860280e89486db0">sort_by_key</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, K_it k_first, K_it k_last, V_it v_first, C comp)</td></tr>
<tr class="memdesc:a353174f6b5bd7707b860280e89486db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a capture task to a key-value sort task  <br /></td></tr>
<tr class="separator:a353174f6b5bd7707b860280e89486db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861e098e939c07c592c00e75583a68c0" id="r_a861e098e939c07c592c00e75583a68c0"><td class="memTemplParams" colspan="2">template&lt;typename I , typename U &gt; </td></tr>
<tr class="memitem:a861e098e939c07c592c00e75583a68c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a861e098e939c07c592c00e75583a68c0">find_if</a> (I first, I last, unsigned *idx, U op)</td></tr>
<tr class="memdesc:a861e098e939c07c592c00e75583a68c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a task to find the index of the first element in a range  <br /></td></tr>
<tr class="separator:a861e098e939c07c592c00e75583a68c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039e57d518c43826bba3b8138e034212" id="r_a039e57d518c43826bba3b8138e034212"><td class="memTemplParams" colspan="2">template&lt;typename I , typename U &gt; </td></tr>
<tr class="memitem:a039e57d518c43826bba3b8138e034212"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a039e57d518c43826bba3b8138e034212">find_if</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, unsigned *idx, U op)</td></tr>
<tr class="memdesc:a039e57d518c43826bba3b8138e034212"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a find-if task  <br /></td></tr>
<tr class="separator:a039e57d518c43826bba3b8138e034212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b846063445cd2314c24d03f478d0540" id="r_a8b846063445cd2314c24d03f478d0540"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a8b846063445cd2314c24d03f478d0540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a8b846063445cd2314c24d03f478d0540">min_element</a> (I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:a8b846063445cd2314c24d03f478d0540"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the index of the minimum element in a range  <br /></td></tr>
<tr class="separator:a8b846063445cd2314c24d03f478d0540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88b4d4bcf8bbd9afd8d83b91365cca5" id="r_ad88b4d4bcf8bbd9afd8d83b91365cca5"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ad88b4d4bcf8bbd9afd8d83b91365cca5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#ad88b4d4bcf8bbd9afd8d83b91365cca5">min_element</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:ad88b4d4bcf8bbd9afd8d83b91365cca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a min-element task  <br /></td></tr>
<tr class="separator:ad88b4d4bcf8bbd9afd8d83b91365cca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf68a3c66c67d6dc6870dd38513aa786" id="r_acf68a3c66c67d6dc6870dd38513aa786"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:acf68a3c66c67d6dc6870dd38513aa786"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#acf68a3c66c67d6dc6870dd38513aa786">max_element</a> (I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:acf68a3c66c67d6dc6870dd38513aa786"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the index of the maximum element in a range  <br /></td></tr>
<tr class="separator:acf68a3c66c67d6dc6870dd38513aa786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259989d70b0092f0273ece9283c42dcd" id="r_a259989d70b0092f0273ece9283c42dcd"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a259989d70b0092f0273ece9283c42dcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a259989d70b0092f0273ece9283c42dcd">max_element</a> (<a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> task, I first, I last, unsigned *idx, O op)</td></tr>
<tr class="memdesc:a259989d70b0092f0273ece9283c42dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates the parameters of a max-element task  <br /></td></tr>
<tr class="separator:a259989d70b0092f0273ece9283c42dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8678573f19e01f441a6b4108e62781f3" id="r_a8678573f19e01f441a6b4108e62781f3"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a8678573f19e01f441a6b4108e62781f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a8678573f19e01f441a6b4108e62781f3">offload_until</a> (P &amp;&amp;predicate)</td></tr>
<tr class="memdesc:a8678573f19e01f441a6b4108e62781f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">offloads the captured cudaFlow onto a GPU and repeatedly runs it until the predicate becomes true  <br /></td></tr>
<tr class="separator:a8678573f19e01f441a6b4108e62781f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc6231cc6b1dbf5171b0bc421dc6577" id="r_a0bc6231cc6b1dbf5171b0bc421dc6577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1cudaFlowCapturer.html#a0bc6231cc6b1dbf5171b0bc421dc6577">offload_n</a> (size_t n)</td></tr>
<tr class="memdesc:a0bc6231cc6b1dbf5171b0bc421dc6577"><td class="mdescLeft">&#160;</td><td class="mdescRight">offloads the captured cudaFlow and executes it by the given times  <br /></td></tr>
<tr class="separator:a0bc6231cc6b1dbf5171b0bc421dc6577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5959002af1cf1a1ada3d86a073682232" id="r_a5959002af1cf1a1ada3d86a073682232"><td class="memItemLeft" align="right" valign="top"><a id="a5959002af1cf1a1ada3d86a073682232" name="a5959002af1cf1a1ada3d86a073682232"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>offload</b> ()</td></tr>
<tr class="memdesc:a5959002af1cf1a1ada3d86a073682232"><td class="mdescLeft">&#160;</td><td class="mdescRight">offloads the captured cudaFlow and executes it once <br /></td></tr>
<tr class="separator:a5959002af1cf1a1ada3d86a073682232"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9f64f729511a922781a59663ff1c6250" id="r_a9f64f729511a922781a59663ff1c6250"><td class="memItemLeft" align="right" valign="top"><a id="a9f64f729511a922781a59663ff1c6250" name="a9f64f729511a922781a59663ff1c6250"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>cudaFlow</b></td></tr>
<tr class="separator:a9f64f729511a922781a59663ff1c6250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763b2f90bc53f92d680a635fe28e858e" id="r_a763b2f90bc53f92d680a635fe28e858e"><td class="memItemLeft" align="right" valign="top"><a id="a763b2f90bc53f92d680a635fe28e858e" name="a763b2f90bc53f92d680a635fe28e858e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Executor</b></td></tr>
<tr class="separator:a763b2f90bc53f92d680a635fe28e858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>class to create a cudaFlow graph using stream capture </p>
<p>The usage of <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> is similar to <a class="el" href="classtf_1_1cudaFlow.html" title="class to create a cudaFlow task dependency graph">tf::cudaFlow</a>, except users can call the method <a class="el" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41" title="captures a sequential CUDA operations from the given callable">tf::cudaFlowCapturer::on</a> to capture a sequence of asynchronous CUDA operations through the given stream. The following example creates a CUDA graph that captures two kernel tasks, <code>task_1</code> and <code>task_2</code>, where <code>task_1</code> runs before <code>task_2</code>.</p>
<div class="fragment"><div class="line">taskflow.emplace([](<a class="code hl_class" href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a>&amp; capturer){</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// capture my_kernel_1 through the given stream managed by the capturer</span></div>
<div class="line">  <span class="keyword">auto</span> task_1 = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){</div>
<div class="line">    my_kernel_1&lt;&lt;&lt;grid_1, block_1, shm_size_1, stream&gt;&gt;&gt;(my_parameters_1);</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// capture my_kernel_2 through the given stream managed by the capturer</span></div>
<div class="line">  <span class="keyword">auto</span> task_2 = capturer.<a class="code hl_function" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">on</a>([&amp;](cudaStream_t stream){</div>
<div class="line">    my_kernel_2&lt;&lt;&lt;grid_2, block_2, shm_size_2, stream&gt;&gt;&gt;(my_parameters_2);</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  task_1.<a class="code hl_function" href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">precede</a>(task_2);</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html">tf::cudaFlowCapturer</a></div><div class="ttdoc">class to create a cudaFlow graph using stream capture</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:57</div></div>
<div class="ttc" id="aclasstf_1_1cudaFlowCapturer_html_ad0d937ae0d77239f148b66a77e35db41"><div class="ttname"><a href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41">tf::cudaFlowCapturer::on</a></div><div class="ttdeci">cudaTask on(C &amp;&amp;callable)</div><div class="ttdoc">captures a sequential CUDA operations from the given callable</div><div class="ttdef"><b>Definition</b> cuda_capturer.hpp:1105</div></div>
<div class="ttc" id="aclasstf_1_1cudaTask_html_abdd68287ec4dff4216af34d1db44d1b4"><div class="ttname"><a href="classtf_1_1cudaTask.html#abdd68287ec4dff4216af34d1db44d1b4">tf::cudaTask::precede</a></div><div class="ttdeci">cudaTask &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> cuda_task.hpp:182</div></div>
</div><!-- fragment --><p>Similar to <a class="el" href="classtf_1_1cudaFlow.html" title="class to create a cudaFlow task dependency graph">tf::cudaFlow</a>, a cudaFlowCapturer is a task (<a class="el" href="classtf_1_1Task.html" title="class to create a task handle over a node in a taskflow graph">tf::Task</a>) created from <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> and will be run by <em>one</em> worker thread in the executor. That is, the callable that describes a cudaFlowCapturer will be executed sequentially. Inside a cudaFlow capturer task, different GPU tasks (<a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a>) may run in parallel depending on the selected optimization algorithm. By default, we use <a class="el" href="classtf_1_1cudaRoundRobinCapturing.html" title="class to capture a CUDA graph using a round-robin algorithm">tf::cudaRoundRobinCapturing</a> to transform a user-level graph into a native CUDA graph.</p>
<p>Please refer to <a class="el" href="GPUTaskingcudaFlowCapturer.html">GPU Tasking (cudaFlowCapturer)</a> for details. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aab413b88bf73368f1e6dd98d19016bbc" name="aab413b88bf73368f1e6dd98d19016bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab413b88bf73368f1e6dd98d19016bbc">&#9670;&#160;</a></span>cudaFlowCapturer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::cudaFlowCapturer::cudaFlowCapturer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constrcts a standalone <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">cudaFlowCapturer</a> </p>
<p>A standalone cudaFlow capturer does not go through any taskflow and can be run by the caller thread using explicit offload methods (e.g., <a class="el" href="classtf_1_1cudaFlow.html#a85789ed8a1f47704cf1f1a2b98969444" title="offloads the cudaFlow and executes it once">tf::cudaFlow::offload</a>). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a605f9dfd1363e10d08cbdab29f59a52e" name="a605f9dfd1363e10d08cbdab29f59a52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605f9dfd1363e10d08cbdab29f59a52e">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a copy operation </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#ab70f12050e78b588f5c23d874aa4e538" title="captures a copy task of typed data">cudaFlowCapturer::copy</a> but operates on an existing task. </p>

</div>
</div>
<a id="ab70f12050e78b588f5c23d874aa4e538" name="ab70f12050e78b588f5c23d874aa4e538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70f12050e78b588f5c23d874aa4e538">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt;!<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_same_v</a>&lt; T, void &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::copy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures a copy task of typed data </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>element type (non-void)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>pointer to the target memory block </td></tr>
    <tr><td class="paramname">src</td><td>pointer to the source memory block </td></tr>
    <tr><td class="paramname">num</td><td>number of elements to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">cudaTask</a> handle</dd></dl>
<p>A copy task transfers <code>num*sizeof(T)</code> bytes of data from a source location to a target location. Direction can be arbitrary among CPUs and GPUs. </p>

</div>
</div>
<a id="a1e039a9df87a3aa07069abbf9565280a" name="a1e039a9df87a3aa07069abbf9565280a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e039a9df87a3aa07069abbf9565280a">&#9670;&#160;</a></span>exclusive_scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to an exclusive scan task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a2c9e4fc3b08a74dce4adb0f10c75eaf3" title="similar to cudaFlowCapturer::inclusive_scan but excludes the first value">cudaFlowCapturer::exclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="a039e57d518c43826bba3b8138e034212" name="a039e57d518c43826bba3b8138e034212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039e57d518c43826bba3b8138e034212">&#9670;&#160;</a></span>find_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::find_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a find-if task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a861e098e939c07c592c00e75583a68c0" title="creates a task to find the index of the first element in a range">tf::cudaFlowCapturer::find_if</a> but operates on an existing task. </p>

</div>
</div>
<a id="a861e098e939c07c592c00e75583a68c0" name="a861e098e939c07c592c00e75583a68c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861e098e939c07c592c00e75583a68c0">&#9670;&#160;</a></span>find_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::find_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a task to find the index of the first element in a range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">U</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the range </td></tr>
    <tr><td class="paramname">idx</td><td>pointer to the index of the found element </td></tr>
    <tr><td class="paramname">op</td><td>unary operator which returns <code>true</code> for the required element</td></tr>
  </table>
  </dd>
</dl>
<p>Finds the index <code>idx</code> of the first element in the range <code>[first, last)</code> such that <code>op(*(first+idx))</code> is true. This is equivalent to the parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> idx = 0;</div>
<div class="line"><span class="keywordflow">for</span>(; first != last; ++first, ++idx) {</div>
<div class="line">  <span class="keywordflow">if</span> (p(*first)) {</div>
<div class="line">    <span class="keywordflow">return</span> idx;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> idx;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a17471b99db619c5a6b4645b3dffebe20" name="a17471b99db619c5a6b4645b3dffebe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17471b99db619c5a6b4645b3dffebe20">&#9670;&#160;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::for_each </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a for-each kernel task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a0b2f1bcd59f0b42e0f823818348b4ae7" title="captures a kernel that applies a callable to each dereferenced element of the data array">cudaFlowCapturer::for_each</a> but operates on an existing task. </p>

</div>
</div>
<a id="a0b2f1bcd59f0b42e0f823818348b4ae7" name="a0b2f1bcd59f0b42e0f823818348b4ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2f1bcd59f0b42e0f823818348b4ae7">&#9670;&#160;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::for_each </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures a kernel that applies a callable to each dereferenced element of the data array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>iterator type </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to apply to the dereferenced iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> itr = first; itr != last; i++) {</div>
<div class="line">  callable(*itr);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a05ca5fb4d005f1ff05fd1e4312fcd357" name="a05ca5fb4d005f1ff05fd1e4312fcd357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ca5fb4d005f1ff05fd1e4312fcd357">&#9670;&#160;</a></span>for_each_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::for_each_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a for-each-index kernel task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#aeb877f42ee3a627c40f1c9c84e31ba3c" title="captures a kernel that applies a callable to each index in the range with the step size">cudaFlowCapturer::for_each_index</a> but operates on an existing task. </p>

</div>
</div>
<a id="aeb877f42ee3a627c40f1c9c84e31ba3c" name="aeb877f42ee3a627c40f1c9c84e31ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb877f42ee3a627c40f1c9c84e31ba3c">&#9670;&#160;</a></span>for_each_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::for_each_index </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures a kernel that applies a callable to each index in the range with the step size </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>index type </td></tr>
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>beginning index </td></tr>
    <tr><td class="paramname">last</td><td>last index </td></tr>
    <tr><td class="paramname">step</td><td>step size </td></tr>
    <tr><td class="paramname">callable</td><td>the callable to apply to each element in the data array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="comment">// step is positive [first, last)</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i=first; i&lt;last; i+=step) {</div>
<div class="line">  callable(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// step is negative [first, last)</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> i=first; i&gt;last; i+=step) {</div>
<div class="line">  callable(i);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acc217d04107eda6f93b1ae9b52171106" name="acc217d04107eda6f93b1ae9b52171106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc217d04107eda6f93b1ae9b52171106">&#9670;&#160;</a></span>inclusive_scan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to an inclusive scan task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a67c25aef3adbbc8eca69f8857161509c" title="captures kernels that perform parallel inclusive scan over a range of items">cudaFlowCapturer::inclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="a67c25aef3adbbc8eca69f8857161509c" name="a67c25aef3adbbc8eca69f8857161509c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c25aef3adbbc8eca69f8857161509c">&#9670;&#160;</a></span>inclusive_scan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that perform parallel inclusive scan over a range of items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>binary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output </td></tr>
    <tr><td class="paramname">op</td><td>binary operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, last); i++) {</div>
<div class="line">  *(output + i) = i ? op(*(first+i), *(output+i-1)) : *(first+i);</div>
<div class="line">}</div>
<div class="ttc" id="adistance_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a></div><div class="ttdeci">T distance(T... args)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a850c7c028e1535db1deaecd819d82efb" name="a850c7c028e1535db1deaecd819d82efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850c7c028e1535db1deaecd819d82efb">&#9670;&#160;</a></span>kernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::kernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a kernel operation </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a6f06c7f6954d8d67ad89f0eddfe285e9" title="captures a kernel">cudaFlowCapturer::kernel</a> but operates on an existing task. </p>

</div>
</div>
<a id="a6f06c7f6954d8d67ad89f0eddfe285e9" name="a6f06c7f6954d8d67ad89f0eddfe285e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f06c7f6954d8d67ad89f0eddfe285e9">&#9670;&#160;</a></span>kernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::kernel </td>
          <td>(</td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim3&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures a kernel </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>kernel function type </td></tr>
    <tr><td class="paramname">ArgsT</td><td>kernel function parameters type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>configured grid </td></tr>
    <tr><td class="paramname">b</td><td>configured block </td></tr>
    <tr><td class="paramname">s</td><td>configured shared memory size in bytes </td></tr>
    <tr><td class="paramname">f</td><td>kernel function </td></tr>
    <tr><td class="paramname">args</td><td>arguments to forward to the kernel function by copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">cudaTask</a> handle </dd></dl>

</div>
</div>
<a id="aa1d016b56c06cb28eabfebfdd7dbb24d" name="aa1d016b56c06cb28eabfebfdd7dbb24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d016b56c06cb28eabfebfdd7dbb24d">&#9670;&#160;</a></span>make_optimizer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OPT , typename ... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OPT &amp; tf::cudaFlowCapturer::make_optimizer </td>
          <td>(</td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>selects a different optimization algorithm </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OPT</td><td>optimizer type </td></tr>
    <tr><td class="paramname">ArgsT</td><td>arguments types</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to forward to construct the optimizer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the optimizer</dd></dl>
<p>We currently supports the following optimization algorithms to capture a user-described cudaFlow:</p><ul>
<li><a class="el" href="classtf_1_1cudaSequentialCapturing.html" title="class to capture a CUDA graph using a sequential stream">tf::cudaSequentialCapturing</a></li>
<li><a class="el" href="classtf_1_1cudaRoundRobinCapturing.html" title="class to capture a CUDA graph using a round-robin algorithm">tf::cudaRoundRobinCapturing</a></li>
<li><a class="el" href="classtf_1_1cudaLinearCapturing.html" title="class to capture a linear CUDA graph using a sequential stream">tf::cudaLinearCapturing</a></li>
</ul>
<p>By default, <a class="el" href="classtf_1_1cudaFlowCapturer.html" title="class to create a cudaFlow graph using stream capture">tf::cudaFlowCapturer</a> uses the round-robin optimization algorithm with four streams to transform a user-level graph into a native CUDA graph. </p>

</div>
</div>
<a id="a259989d70b0092f0273ece9283c42dcd" name="a259989d70b0092f0273ece9283c42dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259989d70b0092f0273ece9283c42dcd">&#9670;&#160;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::max_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a max-element task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#acf68a3c66c67d6dc6870dd38513aa786" title="finds the index of the maximum element in a range">cudaFlowCapturer::max_element</a> but operates on an existing task. </p>

</div>
</div>
<a id="acf68a3c66c67d6dc6870dd38513aa786" name="acf68a3c66c67d6dc6870dd38513aa786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf68a3c66c67d6dc6870dd38513aa786">&#9670;&#160;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::max_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the index of the maximum element in a range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the range </td></tr>
    <tr><td class="paramname">idx</td><td>solution index of the maximum element </td></tr>
    <tr><td class="paramname">op</td><td>comparison function object</td></tr>
  </table>
  </dd>
</dl>
<p>The function launches kernels asynchronously to find the largest element in the range <code>[first, last)</code> using the given comparator <code>op</code>. The function is equivalent to a parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(first == last) {</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> largest = first;</div>
<div class="line"><span class="keywordflow">for</span> (++first; first != last; ++first) {</div>
<div class="line">  <span class="keywordflow">if</span> (op(*largest, *first)) {</div>
<div class="line">    largest = first;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, largest);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a20db64e086bf8182b350eaf5d8807af9" name="a20db64e086bf8182b350eaf5d8807af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20db64e086bf8182b350eaf5d8807af9">&#9670;&#160;</a></span>memcpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a capture task to a memcpy operation </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#ae84d097cdae9e2e8ce108dea760483ed" title="copies data between host and device asynchronously through a stream">cudaFlowCapturer::memcpy</a> but operates on an existing task. </p>

</div>
</div>
<a id="ae84d097cdae9e2e8ce108dea760483ed" name="ae84d097cdae9e2e8ce108dea760483ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84d097cdae9e2e8ce108dea760483ed">&#9670;&#160;</a></span>memcpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies data between host and device asynchronously through a stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination memory address </td></tr>
    <tr><td class="paramname">src</td><td>source memory address </td></tr>
    <tr><td class="paramname">count</td><td>size in bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<p>The method captures a <code>cudaMemcpyAsync</code> operation through an internal stream. </p>

</div>
</div>
<a id="a4a7c4dd81f5e00e8a4c733417bca3205" name="a4a7c4dd81f5e00e8a4c733417bca3205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7c4dd81f5e00e8a4c733417bca3205">&#9670;&#160;</a></span>memset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a capture task to a memset operation </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a0d38965b380f940bf6cfc6667a281052" title="initializes or sets GPU memory to the given value byte by byte">cudaFlowCapturer::memset</a> but operates on an existing task. </p>

</div>
</div>
<a id="a0d38965b380f940bf6cfc6667a281052" name="a0d38965b380f940bf6cfc6667a281052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d38965b380f940bf6cfc6667a281052">&#9670;&#160;</a></span>memset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initializes or sets GPU memory to the given value byte by byte </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to GPU mempry </td></tr>
    <tr><td class="paramname">v</td><td>value to set for each byte of the specified memory </td></tr>
    <tr><td class="paramname">n</td><td>size in bytes to set</td></tr>
  </table>
  </dd>
</dl>
<p>The method captures a <code>cudaMemsetAsync</code> operation through an internal stream to fill the first <code>count</code> bytes of the memory area pointed to by <code>devPtr</code> with the constant byte value <code>value</code>. </p>

</div>
</div>
<a id="ac2eec500f313481926197ff0b3aed343" name="ac2eec500f313481926197ff0b3aed343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eec500f313481926197ff0b3aed343">&#9670;&#160;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::merge </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that perform parallel merge on two sorted arrays </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>iterator type of the first input array </td></tr>
    <tr><td class="paramname">B</td><td>iterator type of the second input array </td></tr>
    <tr><td class="paramname">C</td><td>iterator type of the output array </td></tr>
    <tr><td class="paramname">Comp</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_first</td><td>iterator to the beginning of the first input array </td></tr>
    <tr><td class="paramname">a_last</td><td>iterator to the end of the first input array </td></tr>
    <tr><td class="paramname">b_first</td><td>iterator to the beginning of the second input array </td></tr>
    <tr><td class="paramname">b_last</td><td>iterator to the end of the second input array </td></tr>
    <tr><td class="paramname">c_first</td><td>iterator to the beginning of the output array </td></tr>
    <tr><td class="paramname">comp</td><td>binary comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>Merges two sorted ranges <code>[a_first, a_last)</code> and <code>[b_first, b_last)</code> into one sorted range beginning at <code>c_first</code>.</p>
<p>A sequence is said to be sorted with respect to a comparator <code>comp</code> if for any iterator it pointing to the sequence and any non-negative integer <code>n</code> such that <code>it + n</code> is a valid iterator pointing to an element of the sequence, <code>comp(*(it + n), *it)</code> evaluates to <code>false</code>. </p>

</div>
</div>
<a id="a4a69fa9de723f703d6d69fc96fdc978f" name="a4a69fa9de723f703d6d69fc96fdc978f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a69fa9de723f703d6d69fc96fdc978f">&#9670;&#160;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>b_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a merge task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#ac2eec500f313481926197ff0b3aed343" title="captures kernels that perform parallel merge on two sorted arrays">cudaFlowCapturer::merge</a> but operates on an existing task. </p>

</div>
</div>
<a id="a2abf795a03b5431c105a70cee4cf5051" name="a2abf795a03b5431c105a70cee4cf5051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abf795a03b5431c105a70cee4cf5051">&#9670;&#160;</a></span>merge_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::merge_by_key </td>
          <td>(</td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_vals_it&#160;</td>
          <td class="paramname"><em>a_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_vals_it&#160;</td>
          <td class="paramname"><em>b_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_keys_it&#160;</td>
          <td class="paramname"><em>c_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vals_it&#160;</td>
          <td class="paramname"><em>c_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that perform parallel key-value merge </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">a_keys_it</td><td>first key iterator type </td></tr>
    <tr><td class="paramname">a_vals_it</td><td>first value iterator type </td></tr>
    <tr><td class="paramname">b_keys_it</td><td>second key iterator type </td></tr>
    <tr><td class="paramname">b_vals_it</td><td>second value iterator type </td></tr>
    <tr><td class="paramname">c_keys_it</td><td>output key iterator type </td></tr>
    <tr><td class="paramname">c_vals_it</td><td>output value iterator type </td></tr>
    <tr><td class="paramname">C</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_keys_first</td><td>iterator to the beginning of the first key range </td></tr>
    <tr><td class="paramname">a_keys_last</td><td>iterator to the end of the first key range </td></tr>
    <tr><td class="paramname">a_vals_first</td><td>iterator to the beginning of the first value range </td></tr>
    <tr><td class="paramname">b_keys_first</td><td>iterator to the beginning of the second key range </td></tr>
    <tr><td class="paramname">b_keys_last</td><td>iterator to the end of the second key range </td></tr>
    <tr><td class="paramname">b_vals_first</td><td>iterator to the beginning of the second value range </td></tr>
    <tr><td class="paramname">c_keys_first</td><td>iterator to the beginning of the output key range </td></tr>
    <tr><td class="paramname">c_vals_first</td><td>iterator to the beginning of the output value range </td></tr>
    <tr><td class="paramname">comp</td><td>comparator</td></tr>
  </table>
  </dd>
</dl>
<p>Performs a key-value merge that copies elements from <code>[a_keys_first, a_keys_last)</code> and <code>[b_keys_first, b_keys_last)</code> into a single range, <code>[c_keys_first, c_keys_last + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</code> such that the resulting range is in ascending key order.</p>
<p>At the same time, the merge copies elements from the two associated ranges <code>[a_vals_first + (a_keys_last - a_keys_first))</code> and <code>[b_vals_first + (b_keys_last - b_keys_first))</code> into a single range, <code>[c_vals_first, c_vals_first + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</code> such that the resulting range is in ascending order implied by each input element's associated key.</p>
<p>For example, assume:</p><ul>
<li><code>a_keys</code> = <code>{8, 1}</code></li>
<li><code>a_vals</code> = <code>{1, 2}</code></li>
<li><code>b_keys</code> = <code>{3, 7}</code></li>
<li><code>b_vals</code> = <code>{3, 4}</code></li>
</ul>
<p>After the merge, we have:</p><ul>
<li><code>c_keys</code> = <code>{1, 3, 7, 8}</code></li>
<li><code>c_vals</code> = <code>{2, 3, 4, 1}</code> </li>
</ul>

</div>
</div>
<a id="a941bd8141ab25430a264041b9dfd6c28" name="a941bd8141ab25430a264041b9dfd6c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941bd8141ab25430a264041b9dfd6c28">&#9670;&#160;</a></span>merge_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename a_keys_it , typename a_vals_it , typename b_keys_it , typename b_vals_it , typename c_keys_it , typename c_vals_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::merge_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_keys_it&#160;</td>
          <td class="paramname"><em>a_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a_vals_it&#160;</td>
          <td class="paramname"><em>a_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_keys_it&#160;</td>
          <td class="paramname"><em>b_keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b_vals_it&#160;</td>
          <td class="paramname"><em>b_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_keys_it&#160;</td>
          <td class="paramname"><em>c_keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vals_it&#160;</td>
          <td class="paramname"><em>c_vals_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a key-value merge task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a2abf795a03b5431c105a70cee4cf5051" title="captures kernels that perform parallel key-value merge">tf::cudaFlowCapturer::merge_by_key</a> but operates on an existing task. </p>

</div>
</div>
<a id="ad88b4d4bcf8bbd9afd8d83b91365cca5" name="ad88b4d4bcf8bbd9afd8d83b91365cca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88b4d4bcf8bbd9afd8d83b91365cca5">&#9670;&#160;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::min_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates the parameters of a min-element task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a8b846063445cd2314c24d03f478d0540" title="finds the index of the minimum element in a range">cudaFlowCapturer::min_element</a> but operates on an existing task. </p>

</div>
</div>
<a id="a8b846063445cd2314c24d03f478d0540" name="a8b846063445cd2314c24d03f478d0540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b846063445cd2314c24d03f478d0540">&#9670;&#160;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::min_element </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the index of the minimum element in a range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the range </td></tr>
    <tr><td class="paramname">idx</td><td>solution index of the minimum element </td></tr>
    <tr><td class="paramname">op</td><td>comparison function object</td></tr>
  </table>
  </dd>
</dl>
<p>The function launches kernels asynchronously to find the smallest element in the range <code>[first, last)</code> using the given comparator <code>op</code>. The function is equivalent to a parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(first == last) {</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> smallest = first;</div>
<div class="line"><span class="keywordflow">for</span> (++first; first != last; ++first) {</div>
<div class="line">  <span class="keywordflow">if</span> (op(*first, *smallest)) {</div>
<div class="line">    smallest = first;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, smallest);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a593335760ea517cea597237137ef9333" name="a593335760ea517cea597237137ef9333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593335760ea517cea597237137ef9333">&#9670;&#160;</a></span>noop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::noop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>captures a no-operation task </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>An empty node performs no operation during execution, but can be used for transitive ordering. For example, a phased execution graph with 2 groups of <code>n</code> nodes with a barrier between them can be represented using an empty node and <code>2*n</code> dependency edges, rather than no empty node and <code>n^2</code> dependency edges. </p>

</div>
</div>
<a id="a168a968d7f5833700fcc14a210ad39bc" name="a168a968d7f5833700fcc14a210ad39bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168a968d7f5833700fcc14a210ad39bc">&#9670;&#160;</a></span>noop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::noop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a task to a no-operation task </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a593335760ea517cea597237137ef9333" title="captures a no-operation task">tf::cudaFlowCapturer::noop</a> but operates on an existing task. </p>

</div>
</div>
<a id="a0bc6231cc6b1dbf5171b0bc421dc6577" name="a0bc6231cc6b1dbf5171b0bc421dc6577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc6231cc6b1dbf5171b0bc421dc6577">&#9670;&#160;</a></span>offload_n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::offload_n </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>offloads the captured cudaFlow and executes it by the given times </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of executions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8678573f19e01f441a6b4108e62781f3" name="a8678573f19e01f441a6b4108e62781f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8678573f19e01f441a6b4108e62781f3">&#9670;&#160;</a></span>offload_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::offload_until </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>offloads the captured cudaFlow onto a GPU and repeatedly runs it until the predicate becomes true </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>predicate type (a binary callable)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>a binary predicate (returns <code>true</code> for stop)</td></tr>
  </table>
  </dd>
</dl>
<p>Immediately offloads the cudaFlow captured so far onto a GPU and repeatedly runs it until the predicate returns <code>true</code>.</p>
<p>By default, if users do not offload the cudaFlow capturer, the executor will offload it once. </p>

</div>
</div>
<a id="ad0d937ae0d77239f148b66a77e35db41" name="ad0d937ae0d77239f148b66a77e35db41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d937ae0d77239f148b66a77e35db41">&#9670;&#160;</a></span>on() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_invocable_r_v</a>&lt; void, C, cudaStream_t &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::on </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures a sequential CUDA operations from the given callable </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type constructible with <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::function&lt;void(cudaStream_t)&gt;</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callable</td><td>a callable to capture CUDA operations with the stream</td></tr>
  </table>
  </dd>
</dl>
<p>This methods applies a stream created by the flow to capture a sequence of CUDA operations defined in the callable. </p>

</div>
</div>
<a id="a5215d459df3a0d7bccac1a1f2ce9d1ee" name="a5215d459df3a0d7bccac1a1f2ce9d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5215d459df3a0d7bccac1a1f2ce9d1ee">&#9670;&#160;</a></span>on() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::enable_if_t</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::is_invocable_r_v</a>&lt; void, C, cudaStream_t &gt;, void &gt; * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to another sequential CUDA operations </p>
<p>The method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#ad0d937ae0d77239f148b66a77e35db41" title="captures a sequential CUDA operations from the given callable">cudaFlowCapturer::on</a> but operates on an existing task. </p>

</div>
</div>
<a id="ac4f9dc0d7ba570ee29709ecd14ce4ba8" name="ac4f9dc0d7ba570ee29709ecd14ce4ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f9dc0d7ba570ee29709ecd14ce4ba8">&#9670;&#160;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a reduction task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a326516e69ca7a1b15aad237428990791" title="captures kernels that perform parallel reduction over a range of items">cudaFlowCapturer::reduce</a> but operates on an existing task. </p>

</div>
</div>
<a id="a326516e69ca7a1b15aad237428990791" name="a326516e69ca7a1b15aad237428990791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326516e69ca7a1b15aad237428990791">&#9670;&#160;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that perform parallel reduction over a range of items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">C</td><td>binary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end </td></tr>
    <tr><td class="paramname">result</td><td>pointer to the result with an initialized value </td></tr>
    <tr><td class="paramname">op</td><td>binary reduction operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = op(*result, *first++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac944c7d20056e0633ef84f1a25b52296" name="ac944c7d20056e0633ef84f1a25b52296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac944c7d20056e0633ef84f1a25b52296">&#9670;&#160;</a></span>single_task() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::single_task </td>
          <td>(</td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>capturers a kernel to runs the given callable with only one thread </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>callable type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>callable to run by a single kernel thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f7e439c336aa43781c3ef1ef0d71154" name="a2f7e439c336aa43781c3ef1ef0d71154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7e439c336aa43781c3ef1ef0d71154">&#9670;&#160;</a></span>single_task() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a single-threaded kernel </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#ac944c7d20056e0633ef84f1a25b52296" title="capturers a kernel to runs the given callable with only one thread">cudaFlowCapturer::single_task</a> but operates on an existing task. </p>

</div>
</div>
<a id="a75851fb2e6825dad5143ee3d4bf16411" name="a75851fb2e6825dad5143ee3d4bf16411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75851fb2e6825dad5143ee3d4bf16411">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a sort task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a3bcb91eb1579451ece602206f20845f4" title="captures kernels that sort the given array">cudaFlowCapturer::sort</a> but operates on an existing task. </p>

</div>
</div>
<a id="a3bcb91eb1579451ece602206f20845f4" name="a3bcb91eb1579451ece602206f20845f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcb91eb1579451ece602206f20845f4">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::sort </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that sort the given array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>iterator type of the first input array </td></tr>
    <tr><td class="paramname">C</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the input array </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the input array </td></tr>
    <tr><td class="paramname">comp</td><td>binary comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>Sorts elements in the range <code>[first, last)</code> with the given comparator. </p>

</div>
</div>
<a id="a353174f6b5bd7707b860280e89486db0" name="a353174f6b5bd7707b860280e89486db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353174f6b5bd7707b860280e89486db0">&#9670;&#160;</a></span>sort_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K_it , typename V_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V_it&#160;</td>
          <td class="paramname"><em>v_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a key-value sort task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#ac1d2e6ba2eca8ad35a5257e7aedc568f" title="captures kernels that sort the given array">tf::cudaFlowCapturer::sort_by_key</a> but operates on an existing task. </p>

</div>
</div>
<a id="ac1d2e6ba2eca8ad35a5257e7aedc568f" name="ac1d2e6ba2eca8ad35a5257e7aedc568f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d2e6ba2eca8ad35a5257e7aedc568f">&#9670;&#160;</a></span>sort_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K_it , typename V_it , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K_it&#160;</td>
          <td class="paramname"><em>k_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V_it&#160;</td>
          <td class="paramname"><em>v_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that sort the given array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_it</td><td>iterator type of the key </td></tr>
    <tr><td class="paramname">V_it</td><td>iterator type of the value </td></tr>
    <tr><td class="paramname">C</td><td>comparator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k_first</td><td>iterator to the beginning of the key array </td></tr>
    <tr><td class="paramname">k_last</td><td>iterator to the end of the key array </td></tr>
    <tr><td class="paramname">v_first</td><td>iterator to the beginning of the value array </td></tr>
    <tr><td class="paramname">comp</td><td>binary comparator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>Sorts key-value elements in <code>[k_first, k_last)</code> and <code>[v_first, v_first + (k_last - k_first))</code> into ascending key order using the given comparator <code>comp</code>. If <code>i</code> and <code>j</code> are any two valid iterators in <code>[k_first, k_last)</code> such that <code>i</code> precedes <code>j</code>, and <code>p</code> and <code>q</code> are iterators in <code>[v_first, v_first + (k_last - k_first))</code> corresponding to <code>i</code> and <code>j</code> respectively, then <code>comp(*j, *i)</code> evaluates to <code>false</code>.</p>
<p>For example, assume:</p><ul>
<li><code>keys</code> are <code>{1, 4, 2, 8, 5, 7}</code></li>
<li><code>values</code> are <code>{'a', 'b', 'c', 'd', 'e', 'f'}</code></li>
</ul>
<p>After sort:</p><ul>
<li><code>keys</code> are <code>{1, 2, 4, 5, 7, 8}</code></li>
<li><code>values</code> are <code>{'a', 'c', 'b', 'e', 'f', 'd'}</code> </li>
</ul>

</div>
</div>
<a id="afa62195f91702a6f5cbdad6fefb97e4c" name="afa62195f91702a6f5cbdad6fefb97e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa62195f91702a6f5cbdad6fefb97e4c">&#9670;&#160;</a></span>transform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a transform kernel task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a99d9a86a7240ebf0767441e4ec2e14c4" title="captures a kernel that transforms an input range to an output range">cudaFlowCapturer::transform</a> but operates on an existing task. </p>

</div>
</div>
<a id="a568dcdd226d7e466e2ee106fcdde5db9" name="a568dcdd226d7e466e2ee106fcdde5db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568dcdd226d7e466e2ee106fcdde5db9">&#9670;&#160;</a></span>transform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a transform kernel task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a99d9a86a7240ebf0767441e4ec2e14c4" title="captures a kernel that transforms an input range to an output range">cudaFlowCapturer::transform</a> but operates on an existing task. </p>

</div>
</div>
<a id="a99d9a86a7240ebf0767441e4ec2e14c4" name="a99d9a86a7240ebf0767441e4ec2e14c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d9a86a7240ebf0767441e4ec2e14c4">&#9670;&#160;</a></span>transform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::transform </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures a kernel that transforms an input range to an output range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning of the input range </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end of the input range </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output range </td></tr>
    <tr><td class="paramname">op</td><td>unary operator to apply to transform each item in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *output++ = op(*first++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac2f527e57e8fe447b9f13ba51e9b9c48" name="ac2f527e57e8fe447b9f13ba51e9b9c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f527e57e8fe447b9f13ba51e9b9c48">&#9670;&#160;</a></span>transform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename I2 , typename O , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::transform </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures a kernel that transforms two input ranges to an output range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I1</td><td>first input iterator type </td></tr>
    <tr><td class="paramname">I2</td><td>second input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">C</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>iterator to the beginning of the input range </td></tr>
    <tr><td class="paramname">last1</td><td>iterator to the end of the input range </td></tr>
    <tr><td class="paramname">first2</td><td>iterato </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output range </td></tr>
    <tr><td class="paramname">op</td><td>binary operator to apply to transform each pair of items in the two input ranges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first1 != last1) {</div>
<div class="line">  *output++ = op(*first1++, *first2++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4a98445624773892048399fca219df05" name="a4a98445624773892048399fca219df05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a98445624773892048399fca219df05">&#9670;&#160;</a></span>transform_exclusive_scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::transform_exclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a transform-exclusive scan task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a91bc91e5f13fda5f119d9b9f5f679782" title="similar to cudaFlowCapturer::transform_inclusive_scan but excludes the first value">cudaFlowCapturer::transform_exclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="a4cdc5bbeeadf0cd1e06c10aa60ec3200" name="a4cdc5bbeeadf0cd1e06c10aa60ec3200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdc5bbeeadf0cd1e06c10aa60ec3200">&#9670;&#160;</a></span>transform_inclusive_scan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::transform_inclusive_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a transform-inclusive scan task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a5a36ae28d5844cf281b1d351c359b1af" title="captures kernels that perform parallel inclusive scan over a range of transformed items">cudaFlowCapturer::transform_inclusive_scan</a> but operates on an existing task. </p>

</div>
</div>
<a id="a5a36ae28d5844cf281b1d351c359b1af" name="a5a36ae28d5844cf281b1d351c359b1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a36ae28d5844cf281b1d351c359b1af">&#9670;&#160;</a></span>transform_inclusive_scan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename B , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::transform_inclusive_scan </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that perform parallel inclusive scan over a range of transformed items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">O</td><td>output iterator type </td></tr>
    <tr><td class="paramname">B</td><td>binary operator type </td></tr>
    <tr><td class="paramname">U</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end </td></tr>
    <tr><td class="paramname">output</td><td>iterator to the beginning of the output </td></tr>
    <tr><td class="paramname">bop</td><td>binary operator </td></tr>
    <tr><td class="paramname">uop</td><td>unary operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/iterator/distance.html">std::distance</a>(first, last); i++) {</div>
<div class="line">  *(output + i) = i ? op(uop(*(first+i)), *(output+i-1)) : uop(*(first+i));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3ba604ae11261bbc2e6b19d79a28157f" name="a3ba604ae11261bbc2e6b19d79a28157f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba604ae11261bbc2e6b19d79a28157f">&#9670;&#160;</a></span>transform_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::transform_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a transform-reduce task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a02045cacdcff36864243aa9ca0c1d2ef" title="captures kernels that perform parallel reduction over a range of transformed items">cudaFlowCapturer::transform_reduce</a> but operates on an existing task. </p>

</div>
</div>
<a id="a02045cacdcff36864243aa9ca0c1d2ef" name="a02045cacdcff36864243aa9ca0c1d2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02045cacdcff36864243aa9ca0c1d2ef">&#9670;&#160;</a></span>transform_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::transform_reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>captures kernels that perform parallel reduction over a range of transformed items </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>input iterator type </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">C</td><td>binary operator type </td></tr>
    <tr><td class="paramname">U</td><td>unary operator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the beginning </td></tr>
    <tr><td class="paramname">last</td><td>iterator to the end </td></tr>
    <tr><td class="paramname">result</td><td>pointer to the result with an initialized value </td></tr>
    <tr><td class="paramname">bop</td><td>binary reduce operator </td></tr>
    <tr><td class="paramname">uop</td><td>unary transform operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1cudaTask.html" title="class to create a task handle over an internal node of a cudaFlow graph">tf::cudaTask</a> handle</dd></dl>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = bop(*result, uop(*first++));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab4fb659f36f0087f880e38f614d224e1" name="ab4fb659f36f0087f880e38f614d224e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fb659f36f0087f880e38f614d224e1">&#9670;&#160;</a></span>transform_uninitialized_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::transform_uninitialized_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to a transform-reduce task of no initialized value </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a4247db18b90679eccb5a1f64743f8577" title="similar to tf::cudaFlowCapturer::transform_reduce but does not assume any initial value to reduce">cudaFlowCapturer::transform_uninitialized_reduce</a> but operates on an existing task. </p>

</div>
</div>
<a id="a4247db18b90679eccb5a1f64743f8577" name="a4247db18b90679eccb5a1f64743f8577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4247db18b90679eccb5a1f64743f8577">&#9670;&#160;</a></span>transform_uninitialized_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::transform_uninitialized_reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>bop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>uop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a02045cacdcff36864243aa9ca0c1d2ef" title="captures kernels that perform parallel reduction over a range of transformed items">tf::cudaFlowCapturer::transform_reduce</a> but does not assume any initial value to reduce </p>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line">*result = uop(*first++);  <span class="comment">// initial value does not involve in the loop</span></div>
<div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = bop(*result, uop(*first++));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8bc9781981da6a26bdff08e015d1260b" name="a8bc9781981da6a26bdff08e015d1260b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc9781981da6a26bdff08e015d1260b">&#9670;&#160;</a></span>uninitialized_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::cudaFlowCapturer::uninitialized_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>updates a capture task to an uninitialized-reduction task </p>
<p>This method is similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a99044cf477b1bd23c120eb8beea28eea" title="similar to tf::cudaFlowCapturer::reduce but does not assume any initial value to reduce">cudaFlowCapturer::uninitialized_reduce</a> but operates on an existing task. </p>

</div>
</div>
<a id="a99044cf477b1bd23c120eb8beea28eea" name="a99044cf477b1bd23c120eb8beea28eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99044cf477b1bd23c120eb8beea28eea">&#9670;&#160;</a></span>uninitialized_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1cudaTask.html">cudaTask</a> tf::cudaFlowCapturer::uninitialized_reduce </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to <a class="el" href="classtf_1_1cudaFlowCapturer.html#a326516e69ca7a1b15aad237428990791" title="captures kernels that perform parallel reduction over a range of items">tf::cudaFlowCapturer::reduce</a> but does not assume any initial value to reduce </p>
<p>This method is equivalent to the parallel execution of the following loop on a GPU:</p>
<div class="fragment"><div class="line">*result = *first++;  <span class="comment">// initial value does not involve in the loop</span></div>
<div class="line"><span class="keywordflow">while</span> (first != last) {</div>
<div class="line">  *result = op(*result, *first++);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cuda__capturer_8hpp_source.html">cuda_capturer.hpp</a></li>
<li><a class="el" href="for__each_8hpp_source.html">for_each.hpp</a></li>
<li><a class="el" href="transform_8hpp_source.html">transform.hpp</a></li>
<li><a class="el" href="reduce_8hpp_source.html">reduce.hpp</a></li>
<li><a class="el" href="scan_8hpp_source.html">scan.hpp</a></li>
<li><a class="el" href="merge_8hpp_source.html">merge.hpp</a></li>
<li><a class="el" href="sort_8hpp_source.html">sort.hpp</a></li>
<li><a class="el" href="find_8hpp_source.html">find.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetf.html">tf</a></li><li class="navelem"><a class="el" href="classtf_1_1cudaFlowCapturer.html">cudaFlowCapturer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
