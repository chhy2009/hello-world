<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Taskflow Handbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/x-icon" href="favicon.ico" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="taskflow_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://taskflow.github.io/">Taskflow</a>
   &#160;<span id="projectnumber">3.2.0-Master-Branch</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtf_1_1Executor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtf_1_1Executor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">tf::Executor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>class to create an executor for running a taskflow graph  
 <a href="classtf_1_1Executor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="executor_8hpp_source.html">executor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4910e89d89146b6d563d598b795eb4a9" id="r_a4910e89d89146b6d563d598b795eb4a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a4910e89d89146b6d563d598b795eb4a9">Executor</a> (size_t N=<a class="elRef" href="http://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency.html">std::thread::hardware_concurrency</a>())</td></tr>
<tr class="memdesc:a4910e89d89146b6d563d598b795eb4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs the executor with <code>N</code> worker threads  <br /></td></tr>
<tr class="separator:a4910e89d89146b6d563d598b795eb4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a511b0cc23b264826373d3dabcef670" id="r_a5a511b0cc23b264826373d3dabcef670"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a5a511b0cc23b264826373d3dabcef670">~Executor</a> ()</td></tr>
<tr class="memdesc:a5a511b0cc23b264826373d3dabcef670"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructs the executor  <br /></td></tr>
<tr class="separator:a5a511b0cc23b264826373d3dabcef670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519777f5783981d534e9e53b99712069" id="r_a519777f5783981d534e9e53b99712069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">run</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;taskflow)</td></tr>
<tr class="memdesc:a519777f5783981d534e9e53b99712069"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a taskflow once  <br /></td></tr>
<tr class="separator:a519777f5783981d534e9e53b99712069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbef53618db1852003a0cd1e1e40c50" id="r_a4bbef53618db1852003a0cd1e1e40c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a4bbef53618db1852003a0cd1e1e40c50">run</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;taskflow)</td></tr>
<tr class="memdesc:a4bbef53618db1852003a0cd1e1e40c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a moved taskflow once  <br /></td></tr>
<tr class="separator:a4bbef53618db1852003a0cd1e1e40c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01c2f31dd3ed3b4dfa1a6c933a58b2f" id="r_ac01c2f31dd3ed3b4dfa1a6c933a58b2f"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ac01c2f31dd3ed3b4dfa1a6c933a58b2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#ac01c2f31dd3ed3b4dfa1a6c933a58b2f">run</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;taskflow, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:ac01c2f31dd3ed3b4dfa1a6c933a58b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a taskflow once and invoke a callback upon completion  <br /></td></tr>
<tr class="separator:ac01c2f31dd3ed3b4dfa1a6c933a58b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c27df2fb7372277f4926f4ab0a0937" id="r_a52c27df2fb7372277f4926f4ab0a0937"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a52c27df2fb7372277f4926f4ab0a0937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a52c27df2fb7372277f4926f4ab0a0937">run</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;taskflow, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:a52c27df2fb7372277f4926f4ab0a0937"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a moved taskflow once and invoke a callback upon completion  <br /></td></tr>
<tr class="separator:a52c27df2fb7372277f4926f4ab0a0937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0617eebc9421f1ba1f82ce6dd02c00" id="r_a6d0617eebc9421f1ba1f82ce6dd02c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a6d0617eebc9421f1ba1f82ce6dd02c00">run_n</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;taskflow, size_t N)</td></tr>
<tr class="memdesc:a6d0617eebc9421f1ba1f82ce6dd02c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a taskflow for <code>N</code> times  <br /></td></tr>
<tr class="separator:a6d0617eebc9421f1ba1f82ce6dd02c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10a12c9e14c8132e414c9a48443d938" id="r_ad10a12c9e14c8132e414c9a48443d938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#ad10a12c9e14c8132e414c9a48443d938">run_n</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;taskflow, size_t N)</td></tr>
<tr class="memdesc:ad10a12c9e14c8132e414c9a48443d938"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a moved taskflow for <code>N</code> times  <br /></td></tr>
<tr class="separator:ad10a12c9e14c8132e414c9a48443d938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd99b189457d1a00a33cd22339694fcd" id="r_abd99b189457d1a00a33cd22339694fcd"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:abd99b189457d1a00a33cd22339694fcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#abd99b189457d1a00a33cd22339694fcd">run_n</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;taskflow, size_t N, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:abd99b189457d1a00a33cd22339694fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a taskflow for <code>N</code> times and then invokes a callback  <br /></td></tr>
<tr class="separator:abd99b189457d1a00a33cd22339694fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14430ac62f0e64e9e21712ba35c22ea" id="r_ad14430ac62f0e64e9e21712ba35c22ea"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ad14430ac62f0e64e9e21712ba35c22ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#ad14430ac62f0e64e9e21712ba35c22ea">run_n</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;taskflow, size_t N, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:ad14430ac62f0e64e9e21712ba35c22ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a moved taskflow for <code>N</code> times and then invokes a callback  <br /></td></tr>
<tr class="separator:ad14430ac62f0e64e9e21712ba35c22ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f52e9dd64b65aba32ca0e13c1ed300a" id="r_a0f52e9dd64b65aba32ca0e13c1ed300a"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a0f52e9dd64b65aba32ca0e13c1ed300a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a0f52e9dd64b65aba32ca0e13c1ed300a">run_until</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;taskflow, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:a0f52e9dd64b65aba32ca0e13c1ed300a"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a taskflow multiple times until the predicate becomes true  <br /></td></tr>
<tr class="separator:a0f52e9dd64b65aba32ca0e13c1ed300a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10fac2869d80049e5a75d2084a78eda" id="r_ab10fac2869d80049e5a75d2084a78eda"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:ab10fac2869d80049e5a75d2084a78eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#ab10fac2869d80049e5a75d2084a78eda">run_until</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;taskflow, P &amp;&amp;pred)</td></tr>
<tr class="memdesc:ab10fac2869d80049e5a75d2084a78eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a moved taskflow and keeps running it until the predicate becomes true  <br /></td></tr>
<tr class="separator:ab10fac2869d80049e5a75d2084a78eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84856e5c4c605fcb3cbfbcad069a6a8" id="r_af84856e5c4c605fcb3cbfbcad069a6a8"><td class="memTemplParams" colspan="2">template&lt;typename P , typename C &gt; </td></tr>
<tr class="memitem:af84856e5c4c605fcb3cbfbcad069a6a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#af84856e5c4c605fcb3cbfbcad069a6a8">run_until</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;taskflow, P &amp;&amp;pred, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:af84856e5c4c605fcb3cbfbcad069a6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a taskflow multiple times until the predicate becomes true and then invokes the callback  <br /></td></tr>
<tr class="separator:af84856e5c4c605fcb3cbfbcad069a6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30c6947f060e4bdf344e90b6b44fc70" id="r_af30c6947f060e4bdf344e90b6b44fc70"><td class="memTemplParams" colspan="2">template&lt;typename P , typename C &gt; </td></tr>
<tr class="memitem:af30c6947f060e4bdf344e90b6b44fc70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#af30c6947f060e4bdf344e90b6b44fc70">run_until</a> (<a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;taskflow, P &amp;&amp;pred, C &amp;&amp;callable)</td></tr>
<tr class="memdesc:af30c6947f060e4bdf344e90b6b44fc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a moved taskflow and keeps running it until the predicate becomes true and then invokes the callback  <br /></td></tr>
<tr class="separator:af30c6947f060e4bdf344e90b6b44fc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aa252f70e9a40020a1e5a89d485b85" id="r_ab9aa252f70e9a40020a1e5a89d485b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#ab9aa252f70e9a40020a1e5a89d485b85">wait_for_all</a> ()</td></tr>
<tr class="memdesc:ab9aa252f70e9a40020a1e5a89d485b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait for all tasks to complete  <br /></td></tr>
<tr class="separator:ab9aa252f70e9a40020a1e5a89d485b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2d464ab2a84ecb3b3ea7747e8e276b" id="r_a9d2d464ab2a84ecb3b3ea7747e8e276b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a9d2d464ab2a84ecb3b3ea7747e8e276b">num_workers</a> () const noexcept</td></tr>
<tr class="memdesc:a9d2d464ab2a84ecb3b3ea7747e8e276b"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the number of worker threads  <br /></td></tr>
<tr class="separator:a9d2d464ab2a84ecb3b3ea7747e8e276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6c28ed58211e4c27a99571e5bf0b6c" id="r_a6d6c28ed58211e4c27a99571e5bf0b6c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a6d6c28ed58211e4c27a99571e5bf0b6c">num_topologies</a> () const</td></tr>
<tr class="memdesc:a6d6c28ed58211e4c27a99571e5bf0b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the number of running topologies at the time of this call  <br /></td></tr>
<tr class="separator:a6d6c28ed58211e4c27a99571e5bf0b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb438dc0f7b9e1ae2fe3f240c82f174" id="r_a5fb438dc0f7b9e1ae2fe3f240c82f174"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a5fb438dc0f7b9e1ae2fe3f240c82f174">num_taskflows</a> () const</td></tr>
<tr class="memdesc:a5fb438dc0f7b9e1ae2fe3f240c82f174"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the number of running taskflows with moved ownership  <br /></td></tr>
<tr class="separator:a5fb438dc0f7b9e1ae2fe3f240c82f174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6487d589cb1f6b078b69fd3bb1082345" id="r_a6487d589cb1f6b078b69fd3bb1082345"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a6487d589cb1f6b078b69fd3bb1082345">this_worker_id</a> () const</td></tr>
<tr class="memdesc:a6487d589cb1f6b078b69fd3bb1082345"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the id of the caller thread in this executor  <br /></td></tr>
<tr class="separator:a6487d589cb1f6b078b69fd3bb1082345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6866c8f1b6a2e932f06d0b4eb032c0" id="r_a1e6866c8f1b6a2e932f06d0b4eb032c0"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:a1e6866c8f1b6a2e932f06d0b4eb032c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a1e6866c8f1b6a2e932f06d0b4eb032c0">async</a> (F &amp;&amp;f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1e6866c8f1b6a2e932f06d0b4eb032c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a given function asynchronously  <br /></td></tr>
<tr class="separator:a1e6866c8f1b6a2e932f06d0b4eb032c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acee1670e9f246c7ccd7f6a63f1524" id="r_a51acee1670e9f246c7ccd7f6a63f1524"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:a51acee1670e9f246c7ccd7f6a63f1524"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a51acee1670e9f246c7ccd7f6a63f1524">named_async</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;name, F &amp;&amp;f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:a51acee1670e9f246c7ccd7f6a63f1524"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs a given function asynchronously and gives a name to this task  <br /></td></tr>
<tr class="separator:a51acee1670e9f246c7ccd7f6a63f1524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf71e7ec0026ddfce79c912264369bc9" id="r_abf71e7ec0026ddfce79c912264369bc9"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:abf71e7ec0026ddfce79c912264369bc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#abf71e7ec0026ddfce79c912264369bc9">silent_async</a> (F &amp;&amp;f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:abf71e7ec0026ddfce79c912264369bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1Executor.html#a1e6866c8f1b6a2e932f06d0b4eb032c0" title="runs a given function asynchronously">tf::Executor::async</a> but does not return a future object  <br /></td></tr>
<tr class="separator:abf71e7ec0026ddfce79c912264369bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1febfaa7a99cac8466263c58fd2a7c06" id="r_a1febfaa7a99cac8466263c58fd2a7c06"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgsT&gt; </td></tr>
<tr class="memitem:a1febfaa7a99cac8466263c58fd2a7c06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a1febfaa7a99cac8466263c58fd2a7c06">named_silent_async</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;name, F &amp;&amp;f, ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1febfaa7a99cac8466263c58fd2a7c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to <a class="el" href="classtf_1_1Executor.html#a51acee1670e9f246c7ccd7f6a63f1524" title="runs a given function asynchronously and gives a name to this task">tf::Executor::named_async</a> but does not return a future object  <br /></td></tr>
<tr class="separator:a1febfaa7a99cac8466263c58fd2a7c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff77def96ae740d648dd84e571237c83" id="r_aff77def96ae740d648dd84e571237c83"><td class="memTemplParams" colspan="2">template&lt;typename Observer , typename... ArgsT&gt; </td></tr>
<tr class="memitem:aff77def96ae740d648dd84e571237c83"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Observer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#aff77def96ae740d648dd84e571237c83">make_observer</a> (ArgsT &amp;&amp;... args)</td></tr>
<tr class="memdesc:aff77def96ae740d648dd84e571237c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs an observer to inspect the activities of worker threads  <br /></td></tr>
<tr class="separator:aff77def96ae740d648dd84e571237c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31081f492c376f7b798de0e430534531" id="r_a31081f492c376f7b798de0e430534531"><td class="memTemplParams" colspan="2">template&lt;typename Observer &gt; </td></tr>
<tr class="memitem:a31081f492c376f7b798de0e430534531"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtf_1_1Executor.html#a31081f492c376f7b798de0e430534531">remove_observer</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Observer &gt; observer)</td></tr>
<tr class="memdesc:a31081f492c376f7b798de0e430534531"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes an observer from the executor  <br /></td></tr>
<tr class="separator:a31081f492c376f7b798de0e430534531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affec621aae59d73fc188ef454008fda2" id="r_affec621aae59d73fc188ef454008fda2"><td class="memItemLeft" align="right" valign="top"><a id="affec621aae59d73fc188ef454008fda2" name="affec621aae59d73fc188ef454008fda2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_observers</b> () const noexcept</td></tr>
<tr class="memdesc:affec621aae59d73fc188ef454008fda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">queries the number of observers <br /></td></tr>
<tr class="separator:affec621aae59d73fc188ef454008fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a61184f9bd9c801d0a5eccecfdbddc641" id="r_a61184f9bd9c801d0a5eccecfdbddc641"><td class="memItemLeft" align="right" valign="top"><a id="a61184f9bd9c801d0a5eccecfdbddc641" name="a61184f9bd9c801d0a5eccecfdbddc641"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FlowBuilder</b></td></tr>
<tr class="separator:a61184f9bd9c801d0a5eccecfdbddc641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48945297ede77a161defc88033ce8a6" id="r_aa48945297ede77a161defc88033ce8a6"><td class="memItemLeft" align="right" valign="top"><a id="aa48945297ede77a161defc88033ce8a6" name="aa48945297ede77a161defc88033ce8a6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Subflow</b></td></tr>
<tr class="separator:aa48945297ede77a161defc88033ce8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d14e26ba8af9e6cc5a32aad8446de7" id="r_af3d14e26ba8af9e6cc5a32aad8446de7"><td class="memItemLeft" align="right" valign="top"><a id="af3d14e26ba8af9e6cc5a32aad8446de7" name="af3d14e26ba8af9e6cc5a32aad8446de7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Runtime</b></td></tr>
<tr class="separator:af3d14e26ba8af9e6cc5a32aad8446de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>class to create an executor for running a taskflow graph </p>
<p>An executor manages a set of worker threads to run one or multiple taskflows using an efficient work-stealing scheduling algorithm.</p>
<div class="fragment"><div class="line"><span class="comment">// Declare an executor and a taskflow</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1Executor.html">tf::Executor</a> executor;</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Taskflow.html">tf::Taskflow</a> taskflow;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add three tasks into the taskflow</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> A = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;This is TaskA\n&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> B = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;This is TaskB\n&quot;</span>; });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1Task.html">tf::Task</a> C = taskflow.<a class="code hl_function" href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">emplace</a>([] () { <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;This is TaskC\n&quot;</span>; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build precedence between tasks</span></div>
<div class="line">A.<a class="code hl_function" href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">precede</a>(B, C);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> fu = executor.<a class="code hl_function" href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">run</a>(taskflow);</div>
<div class="line">fu.wait();                <span class="comment">// block until the execution completes</span></div>
<div class="line"> </div>
<div class="line">executor.<a class="code hl_function" href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">run</a>(taskflow, [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;end of 1 run&quot;</span>; }).wait();</div>
<div class="line">executor.<a class="code hl_function" href="classtf_1_1Executor.html#a6d0617eebc9421f1ba1f82ce6dd02c00">run_n</a>(taskflow, 4);</div>
<div class="line">executor.<a class="code hl_function" href="classtf_1_1Executor.html#ab9aa252f70e9a40020a1e5a89d485b85">wait_for_all</a>();  <span class="comment">// block until all associated executions finish</span></div>
<div class="line">executor.<a class="code hl_function" href="classtf_1_1Executor.html#a6d0617eebc9421f1ba1f82ce6dd02c00">run_n</a>(taskflow, 4, [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;end of 4 runs&quot;</span>; }).wait();</div>
<div class="line">executor.<a class="code hl_function" href="classtf_1_1Executor.html#a0f52e9dd64b65aba32ca0e13c1ed300a">run_until</a>(taskflow, [cnt=0] () <span class="keyword">mutable</span> { <span class="keywordflow">return</span> ++cnt == 10; });</div>
<div class="ttc" id="abasic_ostream_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a></div></div>
<div class="ttc" id="aclasstf_1_1Executor_html"><div class="ttname"><a href="classtf_1_1Executor.html">tf::Executor</a></div><div class="ttdoc">class to create an executor for running a taskflow graph</div><div class="ttdef"><b>Definition</b> executor.hpp:50</div></div>
<div class="ttc" id="aclasstf_1_1Executor_html_a0f52e9dd64b65aba32ca0e13c1ed300a"><div class="ttname"><a href="classtf_1_1Executor.html#a0f52e9dd64b65aba32ca0e13c1ed300a">tf::Executor::run_until</a></div><div class="ttdeci">tf::Future&lt; void &gt; run_until(Taskflow &amp;taskflow, P &amp;&amp;pred)</div><div class="ttdoc">runs a taskflow multiple times until the predicate becomes true</div><div class="ttdef"><b>Definition</b> executor.hpp:1622</div></div>
<div class="ttc" id="aclasstf_1_1Executor_html_a519777f5783981d534e9e53b99712069"><div class="ttname"><a href="classtf_1_1Executor.html#a519777f5783981d534e9e53b99712069">tf::Executor::run</a></div><div class="ttdeci">tf::Future&lt; void &gt; run(Taskflow &amp;taskflow)</div><div class="ttdoc">runs a taskflow once</div><div class="ttdef"><b>Definition</b> executor.hpp:1573</div></div>
<div class="ttc" id="aclasstf_1_1Executor_html_a6d0617eebc9421f1ba1f82ce6dd02c00"><div class="ttname"><a href="classtf_1_1Executor.html#a6d0617eebc9421f1ba1f82ce6dd02c00">tf::Executor::run_n</a></div><div class="ttdeci">tf::Future&lt; void &gt; run_n(Taskflow &amp;taskflow, size_t N)</div><div class="ttdoc">runs a taskflow for N times</div><div class="ttdef"><b>Definition</b> executor.hpp:1595</div></div>
<div class="ttc" id="aclasstf_1_1Executor_html_ab9aa252f70e9a40020a1e5a89d485b85"><div class="ttname"><a href="classtf_1_1Executor.html#ab9aa252f70e9a40020a1e5a89d485b85">tf::Executor::wait_for_all</a></div><div class="ttdeci">void wait_for_all()</div><div class="ttdoc">wait for all tasks to complete</div><div class="ttdef"><b>Definition</b> executor.hpp:1709</div></div>
<div class="ttc" id="aclasstf_1_1FlowBuilder_html_a60d7a666cab71ecfa3010b2efb0d6b57"><div class="ttname"><a href="classtf_1_1FlowBuilder.html#a60d7a666cab71ecfa3010b2efb0d6b57">tf::FlowBuilder::emplace</a></div><div class="ttdeci">Task emplace(C &amp;&amp;callable)</div><div class="ttdoc">creates a static task</div><div class="ttdef"><b>Definition</b> flow_builder.hpp:742</div></div>
<div class="ttc" id="aclasstf_1_1Future_html"><div class="ttname"><a href="classtf_1_1Future.html">tf::Future</a></div><div class="ttdoc">class to access the result of an execution</div><div class="ttdef"><b>Definition</b> core/taskflow.hpp:571</div></div>
<div class="ttc" id="aclasstf_1_1Task_html"><div class="ttname"><a href="classtf_1_1Task.html">tf::Task</a></div><div class="ttdoc">class to create a task handle over a node in a taskflow graph</div><div class="ttdef"><b>Definition</b> task.hpp:187</div></div>
<div class="ttc" id="aclasstf_1_1Task_html_a8c78c453295a553c1c016e4062da8588"><div class="ttname"><a href="classtf_1_1Task.html#a8c78c453295a553c1c016e4062da8588">tf::Task::precede</a></div><div class="ttdeci">Task &amp; precede(Ts &amp;&amp;... tasks)</div><div class="ttdoc">adds precedence links from this to other tasks</div><div class="ttdef"><b>Definition</b> task.hpp:420</div></div>
<div class="ttc" id="aclasstf_1_1Taskflow_html"><div class="ttname"><a href="classtf_1_1Taskflow.html">tf::Taskflow</a></div><div class="ttdoc">class to create a taskflow object</div><div class="ttdef"><b>Definition</b> core/taskflow.hpp:73</div></div>
</div><!-- fragment --><p>All the <code>run</code> methods are <em>thread-safe</em>. You can submit multiple taskflows at the same time to an executor from different threads. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4910e89d89146b6d563d598b795eb4a9" name="a4910e89d89146b6d563d598b795eb4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4910e89d89146b6d563d598b795eb4a9">&#9670;&#160;</a></span>Executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Executor::Executor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency.html">std::thread::hardware_concurrency</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs the executor with <code>N</code> worker threads </p>
<p>The constructor spawns <code>N</code> worker threads to run tasks in a work-stealing loop. The number of workers must be greater than zero or an exception will be thrown. By default, the number of worker threads is equal to the maximum hardware concurrency returned by <a class="elRef" href="http://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency.html">std::thread::hardware_concurrency</a>. </p>

</div>
</div>
<a id="a5a511b0cc23b264826373d3dabcef670" name="a5a511b0cc23b264826373d3dabcef670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a511b0cc23b264826373d3dabcef670">&#9670;&#160;</a></span>~Executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tf::Executor::~Executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructs the executor </p>
<p>The destructor calls <a class="el" href="classtf_1_1Executor.html#ab9aa252f70e9a40020a1e5a89d485b85" title="wait for all tasks to complete">Executor::wait_for_all</a> to wait for all submitted taskflows to complete and then notifies all worker threads to stop and join these threads. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e6866c8f1b6a2e932f06d0b4eb032c0" name="a1e6866c8f1b6a2e932f06d0b4eb032c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6866c8f1b6a2e932f06d0b4eb032c0">&#9670;&#160;</a></span>async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tf::Executor::async </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a given function asynchronously </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>callable type </td></tr>
    <tr><td class="paramname">ArgsT</td><td>parameter types</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>callable object to call </td></tr>
    <tr><td class="paramname">args</td><td>parameters to pass to the callable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that will holds the result of the execution</dd></dl>
<p>The method creates an asynchronous task to launch the given function on the given arguments. Unlike <a class="elRef" href="http://en.cppreference.com/w/cpp/thread/async.html">std::async</a>, the return here is a <em><a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a></em> that holds an optional object to the result. If the asynchronous task is cancelled before it runs, the return is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::nullopt</a></code>, or the value returned by the callable.</p>
<div class="fragment"><div class="line">tf::Fugure&lt;std::optional&lt;int&gt;&gt; future = executor.async([](){</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;create an asynchronous task and returns 1\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">});</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="aff77def96ae740d648dd84e571237c83" name="aff77def96ae740d648dd84e571237c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff77def96ae740d648dd84e571237c83">&#9670;&#160;</a></span>make_observer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Observer , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Observer &gt; tf::Executor::make_observer </td>
          <td>(</td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs an observer to inspect the activities of worker threads </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Observer</td><td>observer type derived from <a class="el" href="classtf_1_1ObserverInterface.html" title="class to derive an executor observer">tf::ObserverInterface</a> </td></tr>
    <tr><td class="paramname">ArgsT</td><td>argument parameter pack</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to forward to the constructor of the observer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the created observer</dd></dl>
<p>Each executor manages a list of observers with shared ownership with callers. For each of these observers, the two member functions, <a class="el" href="classtf_1_1ObserverInterface.html#a3e3a9f7f1d43691794e487b8787b01a0" title="method to call before a worker thread executes a closure">tf::ObserverInterface::on_entry</a> and <a class="el" href="classtf_1_1ObserverInterface.html#aa59a59a59eadd4eb6ba20ecdfcae882b" title="method to call after a worker thread executed a closure">tf::ObserverInterface::on_exit</a> will be called before and after the execution of a task.</p>
<p>This member function is not thread-safe. </p>

</div>
</div>
<a id="a51acee1670e9f246c7ccd7f6a63f1524" name="a51acee1670e9f246c7ccd7f6a63f1524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acee1670e9f246c7ccd7f6a63f1524">&#9670;&#160;</a></span>named_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tf::Executor::named_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a given function asynchronously and gives a name to this task </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>callable type </td></tr>
    <tr><td class="paramname">ArgsT</td><td>parameter types</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the asynchronous task </td></tr>
    <tr><td class="paramname">f</td><td>callable object to call </td></tr>
    <tr><td class="paramname">args</td><td>parameters to pass to the callable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that will holds the result of the execution</dd></dl>
<p>The method creates a named asynchronous task to launch the given function on the given arguments. Naming an asynchronous task is primarily used for profiling and visualizing the task execution timeline. Unlike <a class="elRef" href="http://en.cppreference.com/w/cpp/thread/async.html">std::async</a>, the return here is a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds an optional object to the result. If the asynchronous task is cancelled before it runs, the return is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">std::nullopt</a></code>, or the value returned by the callable.</p>
<div class="fragment"><div class="line">tf::Fugure&lt;std::optional&lt;int&gt;&gt; future = executor.named_async(<span class="stringliteral">&quot;name&quot;</span>, [](){</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;create an asynchronous task with a name and returns 1\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">});</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="a1febfaa7a99cac8466263c58fd2a7c06" name="a1febfaa7a99cac8466263c58fd2a7c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1febfaa7a99cac8466263c58fd2a7c06">&#9670;&#160;</a></span>named_silent_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::Executor::named_silent_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to <a class="el" href="classtf_1_1Executor.html#a51acee1670e9f246c7ccd7f6a63f1524" title="runs a given function asynchronously and gives a name to this task">tf::Executor::named_async</a> but does not return a future object </p>
<p>This member function is more efficient than <a class="el" href="classtf_1_1Executor.html#a51acee1670e9f246c7ccd7f6a63f1524" title="runs a given function asynchronously and gives a name to this task">tf::Executor::named_async</a> and is encouraged to use when there is no data returned.</p>
<div class="fragment"><div class="line">executor.named_silent_async(<span class="stringliteral">&quot;name&quot;</span>, [](){</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;create an asynchronous task with a name and no return\n&quot;</span>;</div>
<div class="line">});</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="a5fb438dc0f7b9e1ae2fe3f240c82f174" name="a5fb438dc0f7b9e1ae2fe3f240c82f174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb438dc0f7b9e1ae2fe3f240c82f174">&#9670;&#160;</a></span>num_taskflows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tf::Executor::num_taskflows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>queries the number of running taskflows with moved ownership </p>
<div class="fragment"><div class="line">executor.run(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(taskflow));</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; executor.num_taskflows();  <span class="comment">// 0 or 1 (taskflow still running)</span></div>
<div class="ttc" id="amove_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a></div><div class="ttdeci">T move(T... args)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6d6c28ed58211e4c27a99571e5bf0b6c" name="a6d6c28ed58211e4c27a99571e5bf0b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6c28ed58211e4c27a99571e5bf0b6c">&#9670;&#160;</a></span>num_topologies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tf::Executor::num_topologies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>queries the number of running topologies at the time of this call </p>
<p>When a taskflow is submitted to an executor, a topology is created to store runtime metadata of the running taskflow. When the execution of the submitted taskflow finishes, its corresponding topology will be removed from the executor.</p>
<div class="fragment"><div class="line">executor.run(taskflow);</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; executor.num_topologies();  <span class="comment">// 0 or 1 (taskflow still running)</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9d2d464ab2a84ecb3b3ea7747e8e276b" name="a9d2d464ab2a84ecb3b3ea7747e8e276b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2d464ab2a84ecb3b3ea7747e8e276b">&#9670;&#160;</a></span>num_workers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tf::Executor::num_workers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>queries the number of worker threads </p>
<p>Each worker represents one unique thread spawned by an executor upon its construction time.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Executor.html">tf::Executor</a> executor(4);</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; executor.num_workers();    <span class="comment">// 4</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a31081f492c376f7b798de0e430534531" name="a31081f492c376f7b798de0e430534531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31081f492c376f7b798de0e430534531">&#9670;&#160;</a></span>remove_observer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Observer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::Executor::remove_observer </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; Observer &gt;&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes an observer from the executor </p>
<p>This member function is not thread-safe. </p>

</div>
</div>
<a id="a4bbef53618db1852003a0cd1e1e40c50" name="a4bbef53618db1852003a0cd1e1e40c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbef53618db1852003a0cd1e1e40c50">&#9670;&#160;</a></span>run() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>taskflow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>runs a moved taskflow once </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a moved <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes a moved taskflow once and returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(taskflow));</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="a52c27df2fb7372277f4926f4ab0a0937" name="a52c27df2fb7372277f4926f4ab0a0937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c27df2fb7372277f4926f4ab0a0937">&#9670;&#160;</a></span>run() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a moved taskflow once and invoke a callback upon completion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a moved <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> object </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to be invoked after this run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes a moved taskflow once and invokes the given callable when the execution completes. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(</div>
<div class="line">  <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(taskflow), [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;done&quot;</span>; }</div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="a519777f5783981d534e9e53b99712069" name="a519777f5783981d534e9e53b99712069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519777f5783981d534e9e53b99712069">&#9670;&#160;</a></span>run() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&#160;</td>
          <td class="paramname"><em>taskflow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>runs a taskflow once </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes the given taskflow once and returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(taskflow);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe.</p>
<dl class="section attention"><dt>Attention</dt><dd>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </dd></dl>

</div>
</div>
<a id="ac01c2f31dd3ed3b4dfa1a6c933a58b2f" name="ac01c2f31dd3ed3b4dfa1a6c933a58b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01c2f31dd3ed3b4dfa1a6c933a58b2f">&#9670;&#160;</a></span>run() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a taskflow once and invoke a callback upon completion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> object </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to be invoked after this run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes the given taskflow once and invokes the given callable when the execution completes. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(taskflow, [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;done&quot;</span>; });</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe.</p>
<dl class="section attention"><dt>Attention</dt><dd>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </dd></dl>

</div>
</div>
<a id="ad10a12c9e14c8132e414c9a48443d938" name="ad10a12c9e14c8132e414c9a48443d938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10a12c9e14c8132e414c9a48443d938">&#9670;&#160;</a></span>run_n() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>runs a moved taskflow for <code>N</code> times </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a moved <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> object </td></tr>
    <tr><td class="paramname">N</td><td>number of runs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes a moved taskflow <code>N</code> times and returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run_n(</div>
<div class="line">  <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(taskflow), 2    <span class="comment">// run the moved taskflow 2 times</span></div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="ad14430ac62f0e64e9e21712ba35c22ea" name="ad14430ac62f0e64e9e21712ba35c22ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14430ac62f0e64e9e21712ba35c22ea">&#9670;&#160;</a></span>run_n() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a moved taskflow for <code>N</code> times and then invokes a callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a moved <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> </td></tr>
    <tr><td class="paramname">N</td><td>number of runs </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to be invoked after this run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes a moved taskflow <code>N</code> times and invokes the given callable when the execution completes. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(</div>
<div class="line">  <span class="comment">// run the moved taskflow 2 times and invoke the lambda to print &quot;done&quot;</span></div>
<div class="line">  <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(taskflow), 2, [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;done&quot;</span>; }</div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="a6d0617eebc9421f1ba1f82ce6dd02c00" name="a6d0617eebc9421f1ba1f82ce6dd02c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0617eebc9421f1ba1f82ce6dd02c00">&#9670;&#160;</a></span>run_n() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>runs a taskflow for <code>N</code> times </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> object </td></tr>
    <tr><td class="paramname">N</td><td>number of runs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes the given taskflow <code>N</code> times and returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run_n(taskflow, 2);  <span class="comment">// run taskflow 2 times</span></div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe.</p>
<dl class="section attention"><dt>Attention</dt><dd>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </dd></dl>

</div>
</div>
<a id="abd99b189457d1a00a33cd22339694fcd" name="abd99b189457d1a00a33cd22339694fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd99b189457d1a00a33cd22339694fcd">&#9670;&#160;</a></span>run_n() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a taskflow for <code>N</code> times and then invokes a callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> </td></tr>
    <tr><td class="paramname">N</td><td>number of runs </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to be invoked after this run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes the given taskflow <code>N</code> times and invokes the given callable when the execution completes. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(</div>
<div class="line">  taskflow, 2, [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;done&quot;</span>; }  <span class="comment">// runs taskflow 2 times and invoke</span></div>
<div class="line">                                             <span class="comment">// the lambda to print &quot;done&quot;</span></div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe.</p>
<dl class="section attention"><dt>Attention</dt><dd>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </dd></dl>

</div>
</div>
<a id="ab10fac2869d80049e5a75d2084a78eda" name="ab10fac2869d80049e5a75d2084a78eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10fac2869d80049e5a75d2084a78eda">&#9670;&#160;</a></span>run_until() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a moved taskflow and keeps running it until the predicate becomes true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a moved <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> object </td></tr>
    <tr><td class="paramname">pred</td><td>a boolean predicate to return <code>true</code> for stop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes a moved taskflow multiple times until the predicate returns <code>true</code>. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(</div>
<div class="line">  <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(taskflow), [](){ <span class="keywordflow">return</span> rand()%10 == 0 }</div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="af30c6947f060e4bdf344e90b6b44fc70" name="af30c6947f060e4bdf344e90b6b44fc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30c6947f060e4bdf344e90b6b44fc70">&#9670;&#160;</a></span>run_until() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a moved taskflow and keeps running it until the predicate becomes true and then invokes the callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a moved <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> </td></tr>
    <tr><td class="paramname">pred</td><td>a boolean predicate to return <code>true</code> for stop </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to be invoked after this run completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes a moved taskflow multiple times until the predicate returns <code>true</code> and then invokes the given callable when the execution completes. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(</div>
<div class="line">  <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(taskflow),</div>
<div class="line">  [](){ <span class="keywordflow">return</span> rand()%10 == 0 }, [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;done&quot;</span>; }</div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="a0f52e9dd64b65aba32ca0e13c1ed300a" name="a0f52e9dd64b65aba32ca0e13c1ed300a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f52e9dd64b65aba32ca0e13c1ed300a">&#9670;&#160;</a></span>run_until() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a taskflow multiple times until the predicate becomes true </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> </td></tr>
    <tr><td class="paramname">pred</td><td>a boolean predicate to return <code>true</code> for stop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes the given taskflow multiple times until the predicate returns <code>true</code>. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(</div>
<div class="line">  taskflow, [](){ <span class="keywordflow">return</span> rand()%10 == 0 }</div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe.</p>
<dl class="section attention"><dt>Attention</dt><dd>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </dd></dl>

</div>
</div>
<a id="af84856e5c4c605fcb3cbfbcad069a6a8" name="af84856e5c4c605fcb3cbfbcad069a6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84856e5c4c605fcb3cbfbcad069a6a8">&#9670;&#160;</a></span>run_until() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtf_1_1Future.html">tf::Future</a>&lt; void &gt; tf::Executor::run_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtf_1_1Taskflow.html">Taskflow</a> &amp;&#160;</td>
          <td class="paramname"><em>taskflow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs a taskflow multiple times until the predicate becomes true and then invokes the callback </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskflow</td><td>a <a class="el" href="classtf_1_1Taskflow.html" title="class to create a taskflow object">tf::Taskflow</a> </td></tr>
    <tr><td class="paramname">pred</td><td>a boolean predicate to return <code>true</code> for stop </td></tr>
    <tr><td class="paramname">callable</td><td>a callable object to be invoked after this run completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> that holds the result of the execution</dd></dl>
<p>This member function executes the given taskflow multiple times until the predicate returns <code>true</code> and then invokes the given callable when the execution completes. This member function returns a <a class="el" href="classtf_1_1Future.html" title="class to access the result of an execution">tf::Future</a> object that eventually holds the result of the execution.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Future.html">tf::Future&lt;void&gt;</a> future = executor.run(</div>
<div class="line">  taskflow, [](){ <span class="keywordflow">return</span> rand()%10 == 0 }, [](){ <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;done&quot;</span>; }</div>
<div class="line">);</div>
<div class="line"><span class="comment">// do something else</span></div>
<div class="line">future.wait();</div>
</div><!-- fragment --><p>This member function is thread-safe.</p>
<dl class="section attention"><dt>Attention</dt><dd>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </dd></dl>

</div>
</div>
<a id="abf71e7ec0026ddfce79c912264369bc9" name="abf71e7ec0026ddfce79c912264369bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf71e7ec0026ddfce79c912264369bc9">&#9670;&#160;</a></span>silent_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... ArgsT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tf::Executor::silent_async </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgsT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>similar to <a class="el" href="classtf_1_1Executor.html#a1e6866c8f1b6a2e932f06d0b4eb032c0" title="runs a given function asynchronously">tf::Executor::async</a> but does not return a future object </p>
<p>This member function is more efficient than <a class="el" href="classtf_1_1Executor.html#a1e6866c8f1b6a2e932f06d0b4eb032c0" title="runs a given function asynchronously">tf::Executor::async</a> and is encouraged to use when there is no data returned.</p>
<div class="fragment"><div class="line">executor.silent_async([](){</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; <span class="stringliteral">&quot;create an asynchronous task with no return\n&quot;</span>;</div>
<div class="line">});</div>
</div><!-- fragment --><p>This member function is thread-safe. </p>

</div>
</div>
<a id="a6487d589cb1f6b078b69fd3bb1082345" name="a6487d589cb1f6b078b69fd3bb1082345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6487d589cb1f6b078b69fd3bb1082345">&#9670;&#160;</a></span>this_worker_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tf::Executor::this_worker_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>queries the id of the caller thread in this executor </p>
<p>Each worker has an unique id in the range of <code>0</code> to <code>N-1</code> associated with its parent executor. If the caller thread does not belong to the executor, <code>-1</code> is returned.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1Executor.html">tf::Executor</a> executor(4);   <span class="comment">// 4 workers in the executor</span></div>
<div class="line">executor.this_worker_id();  <span class="comment">// -1 (main thread is not a worker)</span></div>
<div class="line"> </div>
<div class="line">taskflow.emplace([&amp;](){</div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::cout</a> &lt;&lt; executor.this_worker_id();  <span class="comment">// 0, 1, 2, or 3</span></div>
<div class="line">});</div>
<div class="line">executor.run(taskflow);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab9aa252f70e9a40020a1e5a89d485b85" name="ab9aa252f70e9a40020a1e5a89d485b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aa252f70e9a40020a1e5a89d485b85">&#9670;&#160;</a></span>wait_for_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tf::Executor::wait_for_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait for all tasks to complete </p>
<p>This member function waits until all submitted tasks (e.g., taskflows, asynchronous tasks) to finish.</p>
<div class="fragment"><div class="line">executor.run(taskflow1);</div>
<div class="line">executor.run_n(taskflow2, 10);</div>
<div class="line">executor.run_n(taskflow3, 100);</div>
<div class="line">executor.wait_for_all();  <span class="comment">// wait until the above submitted taskflows finish</span></div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="executor_8hpp_source.html">executor.hpp</a></li>
<li><a class="el" href="cudaflow_8hpp_source.html">cudaflow.hpp</a></li>
<li><a class="el" href="syclflow_8hpp_source.html">syclflow.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetf.html">tf</a></li><li class="navelem"><a class="el" href="classtf_1_1Executor.html">Executor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
